<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>SalamStudioPro — KDP Visual Editor</title>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.min.js"></script>
  <script>
    pdfjsLib.GlobalWorkerOptions.workerSrc =
      "https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.4.168/pdf.worker.min.js";
  </script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/6.5.0/fabric.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>

  <style>
    :root { --bg:#0b1020; --card:#121a33; --muted:#9aa6c3; --text:#eaf0ff; --accent:#7aa2ff; }
    body { margin:0; font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial; background:var(--bg); color:var(--text); }
    header { padding:14px 16px; border-bottom:1px solid rgba(255,255,255,.08); display:flex; gap:12px; align-items:center; }
    header h1 { font-size:16px; margin:0; font-weight:800; letter-spacing:.2px; }
    .wrap { display:grid; grid-template-columns: 360px 1fr; gap:14px; padding:14px; }
    .panel, .viewer { background:var(--card); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:12px; }
    .panel h2, .viewer h2 { font-size:13px; margin:6px 0 10px; color:var(--muted); font-weight:800; letter-spacing:.2px; }
    label { display:block; font-size:12px; color:var(--muted); margin:10px 0 6px; }
    input, select, button { width:100%; box-sizing:border-box; border-radius:12px; border:1px solid rgba(255,255,255,.12); background:rgba(255,255,255,.06); color:var(--text); padding:10px; }
    button { cursor:pointer; font-weight:800; }
    button.primary { background:linear-gradient(180deg, rgba(122,162,255,.95), rgba(122,162,255,.75)); border:none; color:#06102b; }
    button.ghost { background:transparent; }
    .row { display:grid; grid-template-columns: 1fr 1fr; gap:10px; }
    .toolbar { display:flex; flex-wrap:wrap; gap:8px; margin:8px 0 10px; }
    .toolbar button { width:auto; padding:10px 12px; }
    .muted { color:var(--muted); font-size:12px; line-height:1.4; }
    canvas { width:100% !important; height:auto !important; border-radius:14px; background:#0f1733; }
    .pager { display:flex; gap:10px; align-items:center; margin-top:10px; }
    .pager button { width:auto; }
    .small { font-size:12px; color:var(--muted); }
    .chip { display:inline-block; padding:6px 10px; border-radius:999px; background:rgba(255,255,255,.08); color:var(--muted); font-size:12px; }
  </style>
</head>

<body>
<header>
  <h1>SalamStudioPro — KDP Visual Editor</h1>
  <span class="chip">Upload PDF or DOCX • Add/Edit Text • Export KDP PDF</span>
</header>

<div class="wrap">
  <div class="panel">
    <h2>Upload</h2>
    <label>Upload PDF or DOCX</label>
    <input id="fileInput" type="file" accept=".pdf,.docx,application/pdf,application/vnd.openxmlformats-officedocument.wordprocessingml.document"/>

    <p class="muted" id="uploadNote">
      DOCX files are converted to PDF on the server (LibreOffice), then opened here.
    </p>

    <h2>Book setup</h2>
    <div class="row">
      <div>
        <label>Trim size</label>
        <select id="trimSelect">
          <option value="6x9">6 × 9 in</option>
          <option value="8.5x11">8.5 × 11 in</option>
          <option value="5x8">5 × 8 in</option>
          <option value="5.5x8.5">5.5 × 8.5 in</option>
          <option value="7x10">7 × 10 in</option>
          <option value="8x10">8 × 10 in</option>
          <option value="custom">Custom</option>
        </select>
      </div>
      <div>
        <label>Bleed</label>
        <select id="bleedSelect">
          <option value="none">No bleed</option>
          <option value="bleed">Bleed (+0.125" each side)</option>
        </select>
      </div>
    </div>

    <div class="row">
      <div>
        <label>Custom width (in)</label>
        <input id="cw" type="number" step="0.01" value="6" disabled />
      </div>
      <div>
        <label>Custom height (in)</label>
        <input id="ch" type="number" step="0.01" value="9" disabled />
      </div>
    </div>

    <label>Safe margin guide (in)</label>
    <input id="safeMargin" type="number" step="0.01" value="0.25" />

    <h2>Export</h2>
    <button class="primary" id="exportBtn" disabled>Export KDP PDF</button>
    <p class="small" id="exportInfo"></p>

    <p class="muted">
      Editing original PDF/DOCX text is not reliable. This app lets you add/edit text boxes and move them around safely.
    </p>
  </div>

  <div class="viewer">
    <h2>Editor</h2>

    <div class="toolbar">
      <button id="addTextBtn" class="ghost" disabled>+ Text</button>
      <button id="addImageBtn" class="ghost" disabled>+ Image</button>
      <input id="imgInput" type="file" accept="image/*" style="display:none"/>
      <button id="fontPlus" class="ghost" disabled>A+</button>
      <button id="fontMinus" class="ghost" disabled>A-</button>
      <button id="boldBtn" class="ghost" disabled>Bold</button>
      <button id="deleteBtn" class="ghost" disabled>Delete</button>
      <button id="toggleGuidesBtn" class="ghost" disabled>Guides</button>
    </div>

    <canvas id="designCanvas"></canvas>

    <div class="pager">
      <button id="prevBtn" disabled>◀ Prev</button>
      <button id="nextBtn" disabled>Next ▶</button>
      <span class="small" id="pageLabel">Page: -</span>
    </div>

    <p class="muted" id="status">Upload a PDF or DOCX to start.</p>
  </div>
</div>

<script>
  const PRESETS = {
    "6x9": [6, 9], "8.5x11": [8.5, 11], "5x8": [5, 8],
    "5.5x8.5": [5.5, 8.5], "7x10": [7, 10], "8x10": [8, 10],
  };
  const bleedEach = 0.125;

  function getTargetInches() {
    const trimSel = document.getElementById("trimSelect").value;
    let w,h;
    if (trimSel === "custom") {
      w = parseFloat(document.getElementById("cw").value || "6");
      h = parseFloat(document.getElementById("ch").value || "9");
    } else {
      [w,h] = PRESETS[trimSel];
    }
    const bleed = document.getElementById("bleedSelect").value === "bleed";
    if (bleed) { w += bleedEach*2; h += bleedEach*2; }
    return [w,h];
  }
  function inchesToPx(inches, dpi=150) { return Math.round(inches * dpi); }

  let pdfDoc = null;
  let currentPage = 1;
  let fabricCanvas = null;
  let showGuides = true;
  let overlaysByPage = new Map();

  function setStatus(msg) { document.getElementById("status").textContent = msg; }

  function ensureCanvas(wPx, hPx) {
    const el = document.getElementById("designCanvas");
    el.width = wPx; el.height = hPx;

    if (!fabricCanvas) {
      fabricCanvas = new fabric.Canvas("designCanvas", { preserveObjectStacking:true, selection:true });
      fabricCanvas.on("selection:created", updateControls);
      fabricCanvas.on("selection:updated", updateControls);
      fabricCanvas.on("selection:cleared", updateControls);
      fabricCanvas.on("object:modified", saveOverlays);
      fabricCanvas.on("object:added", saveOverlays);
      fabricCanvas.on("object:removed", saveOverlays);

      fabricCanvas.on("mouse:dblclick", () => {
        const obj = fabricCanvas.getActiveObject();
        if (obj && obj.type === "textbox") obj.enterEditing();
      });
    } else {
      fabricCanvas.setWidth(wPx);
      fabricCanvas.setHeight(hPx);
    }
  }

  function drawGuides() {
    if (!fabricCanvas) return;
    // Remove old guides
    fabricCanvas.getObjects().filter(o => o._isGuide).forEach(o => fabricCanvas.remove(o));
    if (!showGuides) return;

    const [wIn, hIn] = getTargetInches();
    const wPx = fabricCanvas.getWidth(), hPx = fabricCanvas.getHeight();
    const safeIn = parseFloat(document.getElementById("safeMargin").value || "0.25");
    const safeXPx = (safeIn / wIn) * wPx;
    const safeYPx = (safeIn / hIn) * hPx;

    const rect = new fabric.Rect({
      left: safeXPx, top: safeYPx,
      width: wPx - safeXPx*2, height: hPx - safeYPx*2,
      fill: "rgba(0,0,0,0)",
      stroke: "rgba(255,255,255,0.45)",
      strokeDashArray: [10,6],
      selectable:false, evented:false
    });
    rect._isGuide = true;

    fabricCanvas.add(rect);
    fabricCanvas.sendToBack(rect);
  }

  function saveOverlays() {
    if (!fabricCanvas || !pdfDoc) return;
    const objs = fabricCanvas.getObjects().filter(o => !o._isGuide);
    overlaysByPage.set(currentPage, JSON.stringify(objs.map(o => o.toObject())));
  }

  function restoreOverlays(pageNum) {
    if (!fabricCanvas) return;
    fabricCanvas.getObjects().filter(o => !o._isGuide).forEach(o => fabricCanvas.remove(o));

    const json = overlaysByPage.get(pageNum);
    if (!json) return;

    const arr = JSON.parse(json);
    fabric.util.enlivenObjects(arr, (objs) => {
      objs.forEach(o => fabricCanvas.add(o));
      drawGuides();
      fabricCanvas.renderAll();
    });
  }

  async function renderPage(pageNum) {
    const page = await pdfDoc.getPage(pageNum);
    const [wIn, hIn] = getTargetInches();
    const targetW = inchesToPx(wIn, 150);
    const targetH = inchesToPx(hIn, 150);

    ensureCanvas(targetW, targetH);

    const viewport = page.getViewport({ scale: 1.0 });
    const scale = Math.min(targetW / viewport.width, targetH / viewport.height);
    const vp = page.getViewport({ scale });

    const off = document.createElement("canvas");
    off.width = Math.floor(vp.width);
    off.height = Math.floor(vp.height);
    const ctx = off.getContext("2d", { alpha:false });

    await page.render({ canvasContext: ctx, viewport: vp }).promise;

    const dataURL = off.toDataURL("image/jpeg", 0.92);

    await new Promise((resolve) => {
      fabric.Image.fromURL(dataURL, (img) => {
        const cw = fabricCanvas.getWidth(), ch = fabricCanvas.getHeight();
        const s = Math.min(cw / img.width, ch / img.height);
        img.scale(s);
        img.left = (cw - img.getScaledWidth())/2;
        img.top = (ch - img.getScaledHeight())/2;

        fabricCanvas.setBackgroundImage(img, () => {
          restoreOverlays(pageNum);
          drawGuides();
          fabricCanvas.renderAll();
          resolve();
        });
      }, { crossOrigin:"anonymous" });
    });

    document.getElementById("pageLabel").textContent = `Page: ${currentPage} / ${pdfDoc.numPages}`;
    const [ew, eh] = getTargetInches();
    document.getElementById("exportInfo").textContent = `Export size: ${ew.toFixed(3)} × ${eh.toFixed(3)} in`;
  }

  function updateControls() {
    const hasDoc = !!pdfDoc;
    document.getElementById("addTextBtn").disabled = !hasDoc;
    document.getElementById("addImageBtn").disabled = !hasDoc;
    document.getElementById("toggleGuidesBtn").disabled = !hasDoc;
    document.getElementById("exportBtn").disabled = !hasDoc;
    document.getElementById("prevBtn").disabled = !hasDoc || currentPage <= 1;
    document.getElementById("nextBtn").disabled = !hasDoc || currentPage >= pdfDoc.numPages;

    const active = fabricCanvas?.getActiveObject();
    const isText = active && active.type === "textbox";
    document.getElementById("fontPlus").disabled = !isText;
    document.getElementById("fontMinus").disabled = !isText;
    document.getElementById("boldBtn").disabled = !isText;
    document.getElementById("deleteBtn").disabled = !active;
  }

  async function loadPdfBytes(arrayBuffer) {
    pdfDoc = await pdfjsLib.getDocument({ data: arrayBuffer }).promise;
    currentPage = 1;
    overlaysByPage.clear();
    setStatus(`Loaded ${pdfDoc.numPages} pages. Double-click text boxes to edit.`);
    await renderPage(currentPage);
    updateControls();
  }

  async function uploadAndConvertDocx(file) {
    setStatus("Uploading DOCX for conversion…");
    const fd = new FormData();
    fd.append("file", file);

    const res = await fetch("/convert", { method:"POST", body: fd });
    if (!res.ok) throw new Error("DOCX conversion failed");
    const buf = await res.arrayBuffer();
    await loadPdfBytes(buf);
  }

  // Upload handler
  document.getElementById("fileInput").addEventListener("change", async (e) => {
    const file = e.target.files?.[0];
    if (!file) return;
    try {
      if (file.name.toLowerCase().endsWith(".docx")) {
        await uploadAndConvertDocx(file);
      } else {
        const buf = await file.arrayBuffer();
        await loadPdfBytes(buf);
      }
    } catch (err) {
      console.error(err);
      setStatus("Upload failed.");
      alert("Upload/convert failed. Make sure the server is running for DOCX.");
    }
  });

  document.getElementById("trimSelect").addEventListener("change", async (e) => {
    const isCustom = e.target.value === "custom";
    document.getElementById("cw").disabled = !isCustom;
    document.getElementById("ch").disabled = !isCustom;
    if (pdfDoc) { saveOverlays(); await renderPage(currentPage); updateControls(); }
  });

  document.getElementById("bleedSelect").addEventListener("change", async () => {
    if (pdfDoc) { saveOverlays(); await renderPage(currentPage); updateControls(); }
  });

  document.getElementById("cw").addEventListener("input", async () => {
    if (pdfDoc) { saveOverlays(); await renderPage(currentPage); updateControls(); }
  });
  document.getElementById("ch").addEventListener("input", async () => {
    if (pdfDoc) { saveOverlays(); await renderPage(currentPage); updateControls(); }
  });

  document.getElementById("safeMargin").addEventListener("input", () => {
    drawGuides(); fabricCanvas?.renderAll();
  });

  document.getElementById("prevBtn").addEventListener("click", async () => {
    if (!pdfDoc || currentPage <= 1) return;
    saveOverlays(); currentPage--; await renderPage(currentPage); updateControls();
  });

  document.getElementById("nextBtn").addEventListener("click", async () => {
    if (!pdfDoc || currentPage >= pdfDoc.numPages) return;
    saveOverlays(); currentPage++; await renderPage(currentPage); updateControls();
  });

  // Add editable text
  document.getElementById("addTextBtn").addEventListener("click", () => {
    if (!fabricCanvas) return;
    const tb = new fabric.Textbox("Double-click to edit", {
      left: 80, top: 80, width: 420,
      fontSize: 34, fill: "white",
      fontFamily: "Arial"
    });
    fabricCanvas.add(tb);
    fabricCanvas.setActiveObject(tb);
    fabricCanvas.renderAll();
    updateControls();
  });

  // Add image
  document.getElementById("addImageBtn").addEventListener("click", () => {
    document.getElementById("imgInput").click();
  });

  document.getElementById("imgInput").addEventListener("change", (e) => {
    const file = e.target.files?.[0];
    if (!file || !fabricCanvas) return;
    const url = URL.createObjectURL(file);
    fabric.Image.fromURL(url, (img) => {
      img.set({ left: 120, top: 120 });
      img.scaleToWidth(350);
      fabricCanvas.add(img);
      fabricCanvas.setActiveObject(img);
      fabricCanvas.renderAll();
      updateControls();
      URL.revokeObjectURL(url);
    });
    e.target.value = "";
  });

  // Text controls
  document.getElementById("fontPlus").addEventListener("click", () => {
    const obj = fabricCanvas?.getActiveObject();
    if (obj && obj.type === "textbox") { obj.set("fontSize", (obj.fontSize||24) + 2); fabricCanvas.renderAll(); saveOverlays(); }
  });
  document.getElementById("fontMinus").addEventListener("click", () => {
    const obj = fabricCanvas?.getActiveObject();
    if (obj && obj.type === "textbox") { obj.set("fontSize", Math.max(8, (obj.fontSize||24) - 2)); fabricCanvas.renderAll(); saveOverlays(); }
  });
  document.getElementById("boldBtn").addEventListener("click", () => {
    const obj = fabricCanvas?.getActiveObject();
    if (obj && obj.type === "textbox") {
      const w = obj.fontWeight === "bold" ? "normal" : "bold";
      obj.set("fontWeight", w);
      fabricCanvas.renderAll();
      saveOverlays();
    }
  });

  document.getElementById("deleteBtn").addEventListener("click", () => {
    const obj = fabricCanvas?.getActiveObject();
    if (obj) { fabricCanvas.remove(obj); fabricCanvas.discardActiveObject(); fabricCanvas.renderAll(); updateControls(); saveOverlays(); }
  });

  document.getElementById("toggleGuidesBtn").addEventListener("click", () => {
    showGuides = !showGuides;
    drawGuides();
    fabricCanvas?.renderAll();
  });

  // Export
  async function exportPDF() {
    saveOverlays();
    const { jsPDF } = window.jspdf;
    const [wIn, hIn] = getTargetInches();

    const pdf = new jsPDF({ unit:"in", format:[wIn, hIn], compress:true });

    for (let p = 1; p <= pdfDoc.numPages; p++) {
      currentPage = p;
      await renderPage(p);

      // hide guides
      const guides = fabricCanvas.getObjects().filter(o => o._isGuide);
      guides.forEach(g => g.visible = false);
      fabricCanvas.renderAll();

      const dataURL = fabricCanvas.toDataURL({ format:"jpeg", quality:0.92 });

      guides.forEach(g => g.visible = true);
      fabricCanvas.renderAll();

      if (p > 1) pdf.addPage([wIn, hIn], "portrait");
      pdf.addImage(dataURL, "JPEG", 0, 0, wIn, hIn, undefined, "FAST");
    }

    pdf.save("KDP_READY.pdf");
  }

  document.getElementById("exportBtn").addEventListener("click", async () => {
    if (!pdfDoc) return;
    try {
      setStatus("Exporting…");
      await exportPDF();
      setStatus("Export complete.");
    } catch (e) {
      console.error(e);
      setStatus("Export failed.");
      alert("Export failed.");
    }
  });

  updateControls();
</script>
</body>
</html>
