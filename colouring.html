<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Salam Adventures ‚Äì Colouring Game</title>
  <style>
    :root{
      --bg1:#0b1220;
      --text:#e9f2ff;
      --muted:#b9c7e6;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
    }
    html,body{height:100%; margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; color:var(--text);
      background: radial-gradient(1200px 700px at 20% 10%, #203a7a 0%, var(--bg1) 55%, #070b14 100%);
    }
    *{box-sizing:border-box;}
    .wrap{max-width:1100px; margin:18px auto 30px; padding:14px;}

    .controls{
      display:flex; flex-wrap:wrap; gap:10px; align-items:center; justify-content:center;
      margin-bottom:12px;
    }
    .kidbtn{
      border:none; border-radius:18px; padding:12px 14px; cursor:pointer;
      font-weight:800; letter-spacing:.2px; color:#0b1220;
      box-shadow: var(--shadow); display:flex; align-items:center; gap:10px;
      user-select:none; transition: transform .08s ease, filter .2s ease; font-size:14px;
    }
    .kidbtn:hover{transform: translateY(-1px); filter:brightness(1.05);}
    .kidbtn:active{transform: translateY(0px) scale(.99);}
    .kidbtn .emoji{font-size:18px; line-height:1;}
    .kidbtn.active{outline:3px solid rgba(98,255,207,.9); outline-offset:2px;}

    .b1{background: linear-gradient(135deg,#60a5fa,#34d399);}
    .b2{background: linear-gradient(135deg,#fbbf24,#fb7185);}
    .b4{background: linear-gradient(135deg,#34d399,#fbbf24);}
    .b5{background: linear-gradient(135deg,#fb7185,#a78bfa);}
    .b6{background: linear-gradient(135deg,#fbbf24,#60a5fa);}

    .fxStar{background: linear-gradient(135deg,#fde68a,#60a5fa);}
    .fxGlitter{background: linear-gradient(135deg,#a7f3d0,#f472b6);}
    .fxConfetti{background: linear-gradient(135deg,#fb7185,#fbbf24);}

    .toggles{
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:center;
      width:100%;
    }
    .pill{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px; border-radius:999px;
      background: rgba(0,0,0,.28);
      border:1px solid rgba(255,255,255,.14);
      box-shadow: var(--shadow);
      color:var(--muted);
      font-size:12px;
    }
    .pill input{accent-color:#22c55e;}
    .pill input[type="range"]{width:170px;}

    .stage{
      margin-top:10px; border-radius:24px; padding:12px; position:relative;
      box-shadow: 0 20px 60px rgba(0,0,0,.45); overflow:hidden;
    }
    .stage::before{
      content:""; position:absolute; inset:-2px; border-radius:26px; z-index:0; opacity:1;
      background: conic-gradient(from 0deg, #ff3d3d, #ffd93d, #3dff6a, #3ddcff, #7c3dff, #ff3d3d);
      animation: spin 2.8s linear infinite, pulse 1.1s ease-in-out infinite;
    }
    .stage::after{
      content:""; position:absolute; inset:6px; border-radius:20px; z-index:0;
      background: linear-gradient(180deg, rgba(10,20,45,.86), rgba(6,10,20,.88));
    }
    .stage.noflash::before{animation:none; opacity:.35;}
    @keyframes spin{to{transform: rotate(360deg);}}
    @keyframes pulse{0%,100%{filter: brightness(1) saturate(1.2);} 50%{filter: brightness(1.25) saturate(1.8);}}

    .canvasWrap{
      position:relative; z-index:1; padding: 10px; border-radius:18px;
      background: rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.10);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.15);
    }
    canvas{
      width:100%; height:auto; display:block; border-radius:16px; background:#ffffff; touch-action:none;
    }

    .smallstatus{
      margin:10px 6px 0; font-size:12px; color:var(--muted);
      display:flex; gap:10px; flex-wrap:wrap; align-items:center; justify-content:space-between;
    }
    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono","Courier New", monospace;
      font-size:11px; padding:3px 7px; border-radius:8px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.25);
      color:#cfe0ff;
    }

    .panel{
      margin-top:14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.12);
      border-radius:22px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .panelHeader{
      display:flex; align-items:center; justify-content:space-between; gap:12px;
      padding:12px 14px;
      background: linear-gradient(90deg, rgba(34,197,94,.18), rgba(59,130,246,.16), rgba(168,85,247,.14));
      border-bottom:1px solid rgba(255,255,255,.10);
      flex-wrap:wrap;
    }
    .chip{
      font-size:12px; padding:6px 10px; border-radius:999px;
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12);
      color:var(--muted);
      display:inline-flex; align-items:center; gap:8px;
    }
    .panelBody{display:grid; grid-template-columns: 1.1fr 1fr; gap:12px; padding:12px;}
    @media (max-width: 860px){ .panelBody{grid-template-columns: 1fr;} }
    .section{
      background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);
      border-radius:18px;
      padding:12px;
    }
    .section h2{font-size:13px; margin:0 0 10px 0; color:#dbe8ff;}
    .section p{margin:0 0 10px 0; font-size:12px; color:var(--muted);}

    .swatches{display:grid; grid-template-columns: repeat(10, 1fr); gap:8px;}
    .swatch{
      width:100%; aspect-ratio:1/1; border-radius:12px;
      border:1px solid rgba(255,255,255,.16);
      cursor:pointer;
      box-shadow: inset 0 0 0 2px rgba(0,0,0,.12), 0 6px 14px rgba(0,0,0,.25);
      transition: transform .08s ease, filter .2s ease, outline .2s ease;
    }
    .swatch:hover{transform: translateY(-1px); filter: brightness(1.08);}
    .swatch.selected{outline:2px solid rgba(98,255,207,.9); outline-offset:2px;}

    .modeGrid{display:grid; grid-template-columns: repeat(3, 1fr); gap:10px;}
    .modeBtn{
      padding:10px; border-radius:16px; cursor:pointer;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.04);
      color:var(--text);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.12);
      transition: transform .08s ease, border-color .2s ease, filter .2s ease;
      text-align:left; min-height:60px;
    }
    .modeBtn:hover{transform: translateY(-1px); border-color: rgba(98,255,207,.35); filter: brightness(1.06);}
    .modeBtn.active{border-color: rgba(98,255,207,.9); box-shadow: 0 0 0 2px rgba(98,255,207,.25) inset;}
    .modeBtn b{display:block; font-size:13px; margin-bottom:4px;}
    .modeBtn span{display:block; font-size:11px; color:var(--muted); line-height:1.2;}

    .sliders{display:grid; gap:10px; margin-top:10px;}
    .row{display:flex; align-items:center; justify-content:space-between; gap:10px;}
    .row label{font-size:12px; color:var(--muted);}
    .row input[type="range"]{flex:1;}

    .footerRow{
      display:flex; flex-wrap:wrap; gap:10px; justify-content:space-between; align-items:center;
      padding:12px 14px;
      border-top:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      color:var(--muted);
      font-size:12px;
    }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="controls">
      <button class="kidbtn b1" id="prevBtn"><span class="emoji">‚¨ÖÔ∏è</span> Back</button>
      <button class="kidbtn b2" id="nextBtn">Next <span class="emoji">‚û°Ô∏è</span></button>

      <!-- NEW: quick FX buttons -->
      <button class="kidbtn fxStar" id="starsBtn"><span class="emoji">‚≠ê</span> Stars</button>
      <button class="kidbtn fxGlitter" id="glitterBtn"><span class="emoji">‚ú®</span> Glitter</button>
      <button class="kidbtn fxConfetti" id="confettiBtn"><span class="emoji">üéâ</span> Confetti</button>

      <button class="kidbtn b4" id="undoBtn"><span class="emoji">‚Ü©Ô∏è</span> Oops!</button>
      <button class="kidbtn b5" id="cleanBtn"><span class="emoji">üßº</span> Clean Page</button>
      <button class="kidbtn b6" id="saveBtn"><span class="emoji">üíæ</span> Save</button>

      <div class="toggles">
        <div class="pill">
          <input type="checkbox" id="flashToggle" checked />
          <label for="flashToggle">Flashing Border</label>
        </div>

        <div class="pill">
          <label for="size">Brush Size</label>
          <input id="size" type="range" min="3" max="60" value="16" />
          <span class="kbd" id="sizeVal">16</span>
        </div>
      </div>
    </div>

    <div class="stage" id="stage">
      <div class="canvasWrap">
        <canvas id="canvas" width="1200" height="800"></canvas>

        <div class="smallstatus">
          <div>Tip: Tap Fill = one tap to colour an area ¬∑ <span class="kbd">Ctrl</span>+<span class="kbd">Z</span> Undo</div>
          <div style="display:flex; gap:10px; align-items:center; flex-wrap:wrap;">
            <span class="kbd" id="pageLabel">Page 1</span>
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="panelHeader">
        <div style="display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
          <span class="chip" id="modeChip">Mode: Normal Paint</span>
          <span class="chip">Brush Sound: <b id="sfxChip">On</b></span>
          <span class="chip">Tap Fill: <b id="fillChip">Off</b></span>
          <span class="chip">Colour: <span class="kbd" id="currentColour">#2563eb</span></span>
          <span class="chip">Brush: <span class="kbd" id="currentMode">normal</span></span>
        </div>
        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <button class="kidbtn b2" id="fillBtn" style="padding:10px 12px; font-size:13px;"><span class="emoji">ü™£</span> Tap Fill: Off</button>
          <button class="kidbtn b4" id="sfxBtn" style="padding:10px 12px; font-size:13px;"><span class="emoji">üñåÔ∏è</span> SFX: On</button>
          <button class="kidbtn b5" id="eraserBtn" style="padding:10px 12px; font-size:13px;"><span class="emoji">üßΩ</span> Eraser</button>
        </div>
      </div>

      <div class="panelBody">
        <div class="section">
          <h2>üé® Paint Colours</h2>
          <p>Pick a colour and start colouring!</p>
          <div class="swatches" id="colourSwatches"></div>

          <div class="sliders">
            <div class="row">
              <label for="opacity">Opacity</label>
              <input id="opacity" type="range" min="0.05" max="1" value="1" step="0.05" />
              <span class="kbd" id="opacityVal">1.00</span>
            </div>
            <div class="row">
              <label for="smooth">Smoothing</label>
              <input id="smooth" type="range" min="0" max="0.9" value="0.35" step="0.05" />
              <span class="kbd" id="smoothVal">0.35</span>
            </div>
          </div>
        </div>

        <div class="section">
          <h2>‚ú® Brushes & Effects</h2>
          <p>Use the buttons above or pick a brush here.</p>

          <div class="modeGrid">
            <button class="modeBtn active" data-mode="normal"><b>Normal Paint</b><span>Classic smooth brush</span></button>
            <button class="modeBtn" data-mode="stars"><b>Stars</b><span>Star sprinkles</span></button>
            <button class="modeBtn" data-mode="glitter"><b>Glitter Brush</b><span>Sparkles trail behind</span></button>
            <button class="modeBtn" data-mode="rainbow"><b>Rainbow Mix</b><span>Colour-shifting stroke</span></button>
            <button class="modeBtn" data-mode="watercolor"><b>Watercolour</b><span>Soft layered wash</span></button>
            <button class="modeBtn" data-mode="confetti"><b>Confetti Mix</b><span>Paint + confetti dots</span></button>
          </div>

          <div class="sliders">
            <div class="row">
              <label for="glitter">Effect Strength</label>
              <input id="glitter" type="range" min="0" max="1" value="0.55" step="0.05" />
              <span class="kbd" id="glitterVal">0.55</span>
            </div>
            <div class="row">
              <label for="scatter">Effect Scatter</label>
              <input id="scatter" type="range" min="0" max="1" value="0.35" step="0.05" />
              <span class="kbd" id="scatterVal">0.35</span>
            </div>
          </div>
        </div>
      </div>

      <div class="footerRow">
        <div>Undo: <span class="kbd">Ctrl</span>+<span class="kbd">Z</span></div>
        <div>Tap Fill: turn it on, then tap a white area to fill it</div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    // ---- Pages from your repo folder ----
    const pages = [
      "colouring images/butterfly.png",
      "colouring images/car.png",
      "colouring images/chest.png",
      "colouring images/dino.png",
      "colouring images/dog.png",
      "colouring images/doll.png",
      "colouring images/house.png",
      "colouring images/kids.png",
      "colouring images/plane.png",
      "colouring images/prince.png",
      "colouring images/swan.png",
      "colouring images/veg.png"
    ];
    let currentPage = 0;

    // ---- High-DPI helper ----
    function setCanvasSizeForDPR() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const cssW = rect.width;
      const cssH = rect.width * (2/3);

      canvas.style.height = cssH + "px";

      const newW = Math.max(600, Math.round(cssW * dpr));
      const newH = Math.max(400, Math.round(cssH * dpr));

      let snap = null;
      try { snap = ctx.getImageData(0,0,canvas.width,canvas.height); } catch(e){}

      canvas.width = newW;
      canvas.height = newH;

      if (snap) {
        const tmp = document.createElement("canvas");
        tmp.width = snap.width; tmp.height = snap.height;
        tmp.getContext("2d").putImageData(snap,0,0);
        ctx.drawImage(tmp, 0,0, tmp.width,tmp.height, 0,0, canvas.width,canvas.height);
      }
    }

    // ---- Base image drawing ----
    const baseImage = new Image();
    baseImage.decoding = "async";

    function drawBaseImage() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      const ratio = Math.min(
        canvas.width / baseImage.naturalWidth,
        canvas.height / baseImage.naturalHeight
      );

      const newW = Math.round(baseImage.naturalWidth * ratio);
      const newH = Math.round(baseImage.naturalHeight * ratio);

      const x = Math.round((canvas.width - newW) / 2);
      const y = Math.round((canvas.height - newH) / 2);

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(baseImage, x, y, newW, newH);
    }

    // Undo stack
    const undoStack = [];
    const MAX_UNDO = 20;
    function pushUndo() {
      try {
        if (undoStack.length >= MAX_UNDO) undoStack.shift();
        undoStack.push(ctx.getImageData(0,0,canvas.width,canvas.height));
      } catch (e) {}
    }
    function undo() {
      const last = undoStack.pop();
      if (!last) return;
      ctx.putImageData(last,0,0);
    }

    // Load selected page and draw it
    const pageLabel = document.getElementById("pageLabel");
    function loadPage(index) {
      currentPage = (index + pages.length) % pages.length;
      pageLabel.textContent = `Page ${currentPage + 1}`;
      baseImage.src = encodeURI(pages[currentPage]);
    }
    baseImage.onload = () => { drawBaseImage(); undoStack.length = 0; };

    // UI: flashing border toggle
    const stage = document.getElementById('stage');
    document.getElementById('flashToggle').addEventListener('change', (e)=>{
      stage.classList.toggle('noflash', !e.target.checked);
    });

    // Helpers
    const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
    const rand = (a,b) => Math.random()*(b-a)+a;

    // UI elements
    const sizeEl = document.getElementById('size');
    const sizeVal = document.getElementById('sizeVal');
    const opacityEl = document.getElementById('opacity');
    const opacityVal = document.getElementById('opacityVal');
    const smoothEl = document.getElementById('smooth');
    const smoothVal = document.getElementById('smoothVal');
    const glitterEl = document.getElementById('glitter');
    const glitterVal = document.getElementById('glitterVal');
    const scatterEl = document.getElementById('scatter');
    const scatterVal = document.getElementById('scatterVal');

    const modeChip = document.getElementById('modeChip');
    const currentColourEl = document.getElementById('currentColour');
    const currentModeEl = document.getElementById('currentMode');

    let brushSize = parseInt(sizeEl.value,10);
    let brushOpacity = parseFloat(opacityEl.value);
    let smoothing = parseFloat(smoothEl.value);
    let effectStrength = parseFloat(glitterEl.value);
    let scatter = parseFloat(scatterEl.value);

    let brushColour = "#2563eb";
    let mode = "normal";
    let isEraser = false;

    // Tap Fill
    let tapFillOn = false;
    const fillBtn = document.getElementById("fillBtn");
    const fillChip = document.getElementById("fillChip");
    function updateFillUI(){
      fillBtn.classList.toggle("active", tapFillOn);
      fillBtn.innerHTML = tapFillOn
        ? '<span class="emoji">ü™£</span> Tap Fill: On'
        : '<span class="emoji">ü™£</span> Tap Fill: Off';
      fillChip.textContent = tapFillOn ? "On" : "Off";
    }
    fillBtn.addEventListener("click", ()=>{
      tapFillOn = !tapFillOn;
      if (tapFillOn){
        isEraser = false;
        eraserBtn.classList.remove("active");
        currentModeEl.textContent = mode;
      }
      updateFillUI();
    });

    function syncSliders(){
      sizeVal.textContent = brushSize;
      opacityVal.textContent = brushOpacity.toFixed(2);
      smoothVal.textContent = smoothing.toFixed(2);
      glitterVal.textContent = effectStrength.toFixed(2);
      scatterVal.textContent = scatter.toFixed(2);
    }
    sizeEl.addEventListener('input', ()=>{ brushSize = parseInt(sizeEl.value,10); syncSliders(); });
    opacityEl.addEventListener('input', ()=>{ brushOpacity = parseFloat(opacityEl.value); syncSliders(); });
    smoothEl.addEventListener('input', ()=>{ smoothing = parseFloat(smoothEl.value); syncSliders(); });
    glitterEl.addEventListener('input', ()=>{ effectStrength = parseFloat(glitterEl.value); syncSliders(); });
    scatterEl.addEventListener('input', ()=>{ scatter = parseFloat(scatterEl.value); syncSliders(); });

    // Swatches
    const colours = [
      "#000000","#ffffff","#ef4444","#f97316","#facc15",
      "#22c55e","#10b981","#06b6d4","#3b82f6","#6366f1",
      "#a855f7","#ec4899","#f43f5e","#8b5cf6","#14b8a6",
      "#84cc16","#eab308","#fb7185","#60a5fa","#94a3b8"
    ];
    const swatchWrap = document.getElementById('colourSwatches');
    function buildSwatches(){
      swatchWrap.innerHTML = "";
      colours.forEach((c)=>{
        const d = document.createElement('div');
        d.className = "swatch" + (c.toLowerCase() === brushColour.toLowerCase() ? " selected" : "");
        d.style.background = c === "#ffffff" ? "linear-gradient(135deg,#fff,#dbeafe)" : c;
        d.title = c;
        d.addEventListener('click', ()=>{
          brushColour = c;
          isEraser = false;
          eraserBtn.classList.remove('active');
          [...document.querySelectorAll('.swatch')].forEach(x=>x.classList.remove('selected'));
          d.classList.add('selected');
          currentColourEl.textContent = brushColour;
          currentModeEl.textContent = isEraser ? "eraser" : mode;
        });
        swatchWrap.appendChild(d);
      });
    }

    // Modes
    const modeButtons = [...document.querySelectorAll('.modeBtn')];
    function setMode(m){
      mode = m;
      modeButtons.forEach(b=>b.classList.toggle('active', b.dataset.mode === m));
      const names = {
        normal:"Normal Paint",
        stars:"Stars",
        glitter:"Glitter",
        rainbow:"Rainbow",
        watercolor:"Watercolour",
        confetti:"Confetti"
      };
      modeChip.textContent = "Mode: " + (names[m] || m);
      currentModeEl.textContent = isEraser ? "eraser" : m;
      // highlight quick FX buttons
      document.getElementById("starsBtn").classList.toggle("active", m==="stars");
      document.getElementById("glitterBtn").classList.toggle("active", m==="glitter");
      document.getElementById("confettiBtn").classList.toggle("active", m==="confetti");
    }
    modeButtons.forEach(btn=>{
      btn.addEventListener('click', ()=>{
        isEraser = false;
        eraserBtn.classList.remove('active');
        setMode(btn.dataset.mode);
      });
    });

    // NEW quick FX buttons
    document.getElementById("starsBtn").addEventListener("click", ()=>{ isEraser=false; eraserBtn.classList.remove("active"); setMode("stars"); });
    document.getElementById("glitterBtn").addEventListener("click", ()=>{ isEraser=false; eraserBtn.classList.remove("active"); setMode("glitter"); });
    document.getElementById("confettiBtn").addEventListener("click", ()=>{ isEraser=false; eraserBtn.classList.remove("active"); setMode("confetti"); });

    // Eraser
    const eraserBtn = document.getElementById('eraserBtn');
    eraserBtn.addEventListener('click', ()=>{
      isEraser = !isEraser;
      eraserBtn.classList.toggle('active', isEraser);
      if (isEraser) tapFillOn = false;
      updateFillUI();
      currentModeEl.textContent = isEraser ? "eraser" : mode;
    });

    // Brush SFX (kept)
    let sfxOn = true;
    const sfxBtn = document.getElementById('sfxBtn');
    const sfxChip = document.getElementById('sfxChip');
    let audioCtx = null;
    function ensureAudio(){
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") audioCtx.resume();
    }
    sfxBtn.addEventListener('click', ()=>{
      ensureAudio();
      sfxOn = !sfxOn;
      sfxBtn.innerHTML = sfxOn ? '<span class="emoji">üñåÔ∏è</span> SFX: On' : '<span class="emoji">üñåÔ∏è</span> SFX: Off';
      sfxChip.textContent = sfxOn ? "On" : "Off";
    });
    function playBrushSfx(intensity=1){
      if (!sfxOn) return;
      ensureAudio();
      if (!audioCtx) return;

      const bufferSize = 2 * audioCtx.sampleRate;
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const output = noiseBuffer.getChannelData(0);
      for (let i = 0; i < bufferSize; i++) output[i] = (Math.random() * 2 - 1) * 0.6;

      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuffer;

      const filter = audioCtx.createBiquadFilter();
      filter.type = "bandpass";
      filter.frequency.value = 1200;
      filter.Q.value = 0.9;

      const gain = audioCtx.createGain();
      const t = audioCtx.currentTime;
      const g = 0.03 * clamp(intensity, 0.2, 2);
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(g, t + 0.01);
      gain.gain.linearRampToValueAtTime(0, t + 0.08);

      noise.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);

      noise.start();
      noise.stop(t + 0.09);
    }

    // Tap Fill helpers
    function hexToRgb(hex){
      const v = parseInt(hex.replace("#",""),16);
      return [(v>>16)&255,(v>>8)&255,v&255];
    }
    function luminance(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }
    function colorClose(r,g,b, tr,tg,tb, tol){
      return Math.abs(r-tr) <= tol && Math.abs(g-tg) <= tol && Math.abs(b-tb) <= tol;
    }

    function hsvToHex(h, s, v){
      let f = (n, k=(n+h/60)%6) => v - v*s*Math.max(Math.min(k,4-k,1),0);
      const r = Math.round(f(5)*255);
      const g = Math.round(f(3)*255);
      const b = Math.round(f(1)*255);
      return "#" + [r,g,b].map(x=>x.toString(16).padStart(2,"0")).join("");
    }

    // Star drawing
    function drawStar(x,y,r,fill){
      ctx.save();
      ctx.translate(x,y);
      ctx.beginPath();
      const spikes = 5;
      const outer = r;
      const inner = r*0.45;
      let rot = Math.PI/2 * 3;
      let step = Math.PI / spikes;
      ctx.moveTo(0, -outer);
      for (let i=0;i<spikes;i++){
        ctx.lineTo(Math.cos(rot) * outer, Math.sin(rot) * outer);
        rot += step;
        ctx.lineTo(Math.cos(rot) * inner, Math.sin(rot) * inner);
        rot += step;
      }
      ctx.closePath();
      ctx.fillStyle = fill;
      ctx.fill();
      ctx.restore();
    }

    function sprinkleFX(samplePoints){
      if (!samplePoints || samplePoints.length === 0) return;

      const strength = effectStrength; // 0..1
      const scat = scatter;

      const count = Math.min(1000, Math.floor(samplePoints.length * (0.10 + strength*0.25)));
      ctx.save();

      for (let i=0;i<count;i++){
        const p = samplePoints[(Math.random()*samplePoints.length)|0];
        const x = p.x + rand(-7, 7) * (0.35 + scat);
        const y = p.y + rand(-7, 7) * (0.35 + scat);

        if (mode === "stars"){
          ctx.globalAlpha = 0.22 + strength*0.55;
          const starSize = rand(1.5, 5.2) * (0.7 + strength);
          const c = (i%4===0) ? "#ffffff" : (i%4===1 ? "#fde68a" : (i%4===2 ? "#93c5fd" : "#f9a8d4"));
          drawStar(x,y,starSize,c);
        } else if (mode === "confetti"){
          ctx.globalAlpha = 0.16 + strength*0.40;
          ctx.fillStyle = hsvToHex((Date.now()/12 + i*55)%360, 0.85, 1);
          ctx.fillRect(x,y, rand(2,6), rand(2,6));
        } else { // glitter
          ctx.globalAlpha = 0.22 + strength*0.55;
          const r = rand(0.8, 2.8) * (0.7 + strength);
          const c = (i%3===0) ? "#ffffff" : (i%3===1 ? "#fde68a" : "#a7f3d0");
          ctx.fillStyle = c;
          ctx.beginPath();
          ctx.arc(x,y,r,0,Math.PI*2);
          ctx.fill();
        }
      }

      ctx.restore();
    }

    function floodFillTap(x, y, fillHex){
      const w = canvas.width, h = canvas.height;
      if (x<0||y<0||x>=w||y>=h) return [];
      const img = ctx.getImageData(0,0,w,h);
      const d = img.data;
      const i0 = (y*w + x) * 4;

      const tr = d[i0], tg = d[i0+1], tb = d[i0+2], ta = d[i0+3];
      if (ta === 0) return [];
      if (luminance(tr,tg,tb) < 55) return []; // stop on outlines

      const [fr,fg,fb] = hexToRgb(fillHex);
      if (tr===fr && tg===fg && tb===fb) return [];

      const tol = 30;
      const stack = [[x,y]];
      const seen = new Uint8Array(w*h);
      const samples = [];
      const MAX_SAMPLES = 1000;

      const MAX_PIXELS = w*h*0.55;
      let filled = 0;

      while(stack.length){
        const [px,py] = stack.pop();
        if (px<0||py<0||px>=w||py>=h) continue;

        const idx = py*w + px;
        if (seen[idx]) continue;
        seen[idx] = 1;

        const i = idx*4;
        const r = d[i], g = d[i+1], b = d[i+2], a = d[i+3];
        if (a === 0) continue;
        if (luminance(r,g,b) < 55) continue;
        if (!colorClose(r,g,b, tr,tg,tb, tol)) continue;

        d[i] = fr; d[i+1] = fg; d[i+2] = fb; d[i+3] = 255;
        filled++;

        if (samples.length < MAX_SAMPLES) samples.push({x:px, y:py});
        if (filled > MAX_PIXELS) break;

        stack.push([px-1,py],[px+1,py],[px,py-1],[px,py+1]);
      }

      ctx.putImageData(img,0,0);
      return samples;
    }

    // Drawing engine
    function getPos(e){
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      return { x:(e.clientX - rect.left) * dpr, y:(e.clientY - rect.top) * dpr };
    }

    function watercolorStamp(x,y,r,color){
      const g = ctx.createRadialGradient(x,y,0, x,y, r*2.2);
      g.addColorStop(0, color);
      g.addColorStop(1, "rgba(255,255,255,0)");
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x,y, r*2.2, 0, Math.PI*2);
      ctx.fill();
    }

    function drawSegment(prev, cur){
      const dx = cur.x - prev.x, dy = cur.y - prev.y;
      const dist = Math.hypot(dx,dy);
      const steps = Math.max(1, Math.floor(dist / 2));

      ctx.lineCap = "round";
      ctx.lineJoin = "round";

      for (let i=0;i<=steps;i++){
        const t = i/steps;
        const x = prev.x + dx*t;
        const y = prev.y + dy*t;

        const pressure = clamp(dist/30, 0.25, 1.2);
        const r = brushSize * pressure * 0.5;

        if (isEraser){
          ctx.save();
          ctx.globalCompositeOperation = "destination-out";
          ctx.globalAlpha = 1;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
          continue;
        }

        let color = brushColour;
        if (mode === "rainbow"){
          const hue = (Date.now()/18 + x/10) % 360;
          color = hsvToHex(hue, 0.75, 1);
        }

        if (mode === "watercolor"){
          ctx.save();
          ctx.globalCompositeOperation = "multiply";
          ctx.globalAlpha = Math.min(0.22, brushOpacity*0.22);
          watercolorStamp(x + rand(-r*scatter, r*scatter), y + rand(-r*scatter, r*scatter), r, color);
          ctx.globalAlpha = Math.min(0.12, brushOpacity*0.12);
          watercolorStamp(x, y, r*0.85, color);
          ctx.restore();
        } else {
          ctx.save();
          ctx.globalAlpha = brushOpacity;
          ctx.fillStyle = color;
          ctx.beginPath();
          ctx.arc(x, y, r, 0, Math.PI*2);
          ctx.fill();
          ctx.restore();
        }

        // FX trails
        if (mode === "stars" || mode === "glitter" || mode === "confetti" || (mode==="rainbow" && effectStrength>0.25)){
          const count = Math.floor(2 + effectStrength*10);
          for (let k=0;k<count;k++){
            const gx = x + rand(-r*2.2, r*2.2) * (0.3 + scatter);
            const gy = y + rand(-r*2.2, r*2.2) * (0.3 + scatter);

            if (mode === "stars"){
              ctx.save();
              ctx.globalAlpha = 0.20 + effectStrength*0.55;
              const starSize = rand(1.5, 5.4) * (0.7 + effectStrength);
              const c = (k%4===0) ? "#ffffff" : (k%4===1 ? "#fde68a" : (k%4===2 ? "#93c5fd" : "#f9a8d4"));
              drawStar(gx,gy,starSize,c);
              ctx.restore();
            } else if (mode === "confetti"){
              ctx.save();
              ctx.globalAlpha = 0.16 + effectStrength*0.40;
              ctx.fillStyle = hsvToHex((Date.now()/12 + k*55)%360, 0.85, 1);
              ctx.fillRect(gx,gy, rand(2,6), rand(2,6));
              ctx.restore();
            } else {
              ctx.save();
              ctx.globalAlpha = 0.30 + effectStrength*0.55;
              const rr = rand(0.8, 2.8) * (0.7 + effectStrength);
              const cc = (k%3===0) ? "#ffffff" : (k%3===1 ? "#fde68a" : "#a7f3d0");
              ctx.fillStyle = cc;
              ctx.beginPath();
              ctx.arc(gx,gy,rr,0,Math.PI*2);
              ctx.fill();
              ctx.restore();
            }
          }
        }
      }
    }

    // Pointer events
    let drawing = false;
    let lastPoint = null;

    canvas.addEventListener('pointerdown', (e)=>{
      if (tapFillOn){
        pushUndo();
        const p = getPos(e);
        const samples = floodFillTap(Math.floor(p.x), Math.floor(p.y), brushColour);
        if (mode === "stars" || mode === "glitter" || mode === "confetti"){
          sprinkleFX(samples);
        }
        return;
      }
      drawing = true;
      pushUndo();
      lastPoint = getPos(e);
      canvas.setPointerCapture(e.pointerId);
      playBrushSfx(1);
    });

    canvas.addEventListener('pointermove', (e)=>{
      if (!drawing || !lastPoint) return;
      const p = getPos(e);

      // smoothing (light)
      const sx = lastPoint.x + (p.x - lastPoint.x) * (1 - smoothing);
      const sy = lastPoint.y + (p.y - lastPoint.y) * (1 - smoothing);
      const smoothP = {x:sx, y:sy};

      drawSegment(lastPoint, smoothP);
      playBrushSfx(clamp(Math.hypot(smoothP.x-lastPoint.x,smoothP.y-lastPoint.y)/18, 0.3, 1.6));
      lastPoint = smoothP;
    });

    function endDraw(e){
      drawing = false;
      lastPoint = null;
      try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
    }
    canvas.addEventListener('pointerup', endDraw);
    canvas.addEventListener('pointercancel', endDraw);
    canvas.addEventListener('pointerleave', ()=>{ drawing=false; lastPoint=null; });

    // Buttons
    document.getElementById("nextBtn").addEventListener("click", ()=> loadPage(currentPage + 1));
    document.getElementById("prevBtn").addEventListener("click", ()=> loadPage(currentPage - 1));
    document.getElementById("cleanBtn").addEventListener("click", ()=> loadPage(currentPage));
    document.getElementById("undoBtn").addEventListener("click", ()=> undo());

    document.getElementById("saveBtn").addEventListener("click", ()=>{
      const link = document.createElement('a');
      link.download = "my_colouring.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
    });

    window.addEventListener('keydown', (e)=>{
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === 'z'){
        e.preventDefault();
        undo();
      }
    });

    // Init
    function init(){
      syncSliders();
      buildSwatches();
      currentColourEl.textContent = brushColour;
      setMode("normal");
      updateFillUI();
      setCanvasSizeForDPR();
      loadPage(0);
    }
    window.addEventListener("resize", ()=>{
      setCanvasSizeForDPR();
      loadPage(currentPage);
    });

    init();
  </script>
</body>
</html>
