<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Salam Adventures ‚Äì Colouring Game</title>
  <style>
    :root{--bg1:#0b1220;--text:#e9f2ff;--muted:#b9c7e6;--shadow:0 12px 30px rgba(0,0,0,.35);}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--text);
      background:radial-gradient(1200px 700px at 20% 10%,#203a7a 0%,var(--bg1) 55%,#070b14 100%);}
    *{box-sizing:border-box}
    .wrap{max-width:1100px;margin:18px auto 30px;padding:14px}

    .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:center;margin-bottom:12px}
    .kidbtn{
      border:none;border-radius:18px;padding:12px 14px;cursor:pointer;font-weight:800;letter-spacing:.2px;color:#0b1220;
      box-shadow:var(--shadow);display:flex;align-items:center;gap:10px;user-select:none;
      transition:transform .08s ease,filter .2s ease;font-size:14px
    }
    .kidbtn:hover{transform:translateY(-1px);filter:brightness(1.05)}
    .kidbtn:active{transform:translateY(0) scale(.99)}
    .kidbtn .emoji{font-size:18px;line-height:1}
    .kidbtn.active{outline:3px solid rgba(98,255,207,.9);outline-offset:2px}

    .b1{background:linear-gradient(135deg,#60a5fa,#34d399)}
    .b2{background:linear-gradient(135deg,#fbbf24,#fb7185)}
    .b4{background:linear-gradient(135deg,#34d399,#fbbf24)}
    .b5{background:linear-gradient(135deg,#fb7185,#a78bfa)}
    .b6{background:linear-gradient(135deg,#fbbf24,#60a5fa)}

    .fxStar{background:linear-gradient(135deg,#fde68a,#60a5fa)}
    .fxGlitter{background:linear-gradient(135deg,#a7f3d0,#f472b6)}
    .fxConfetti{background:linear-gradient(135deg,#fb7185,#fbbf24)}

    .toggles{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center;width:100%}
    .pill{
      display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:999px;
      background:rgba(0,0,0,.28);border:1px solid rgba(255,255,255,.14);box-shadow:var(--shadow);
      color:var(--muted);font-size:12px
    }
    .pill input{accent-color:#22c55e}
    .pill input[type="range"]{width:170px}

    .stage{margin-top:10px;border-radius:24px;padding:12px;position:relative;box-shadow:0 20px 60px rgba(0,0,0,.45);overflow:hidden}
    .stage::before{
      content:"";position:absolute;inset:-2px;border-radius:26px;z-index:0;opacity:1;
      background:conic-gradient(from 0deg,#ff3d3d,#ffd93d,#3dff6a,#3ddcff,#7c3dff,#ff3d3d);
      animation:spin 2.8s linear infinite,pulse 1.1s ease-in-out infinite
    }
    .stage::after{
      content:"";position:absolute;inset:6px;border-radius:20px;z-index:0;
      background:linear-gradient(180deg,rgba(10,20,45,.86),rgba(6,10,20,.88))
    }
    .stage.noflash::before{animation:none;opacity:.35}
    @keyframes spin{to{transform:rotate(360deg)}}
    @keyframes pulse{0%,100%{filter:brightness(1)saturate(1.2)}50%{filter:brightness(1.25)saturate(1.8)}}

    .canvasWrap{
      position:relative;z-index:1;padding:10px;border-radius:18px;background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.10);box-shadow:inset 0 0 0 1px rgba(0,0,0,.15)
    }
    canvas{width:100%;height:auto;display:block;border-radius:16px;background:#fff;touch-action:none}

    .smallstatus{
      margin:10px 6px 0;font-size:12px;color:var(--muted);display:flex;gap:10px;flex-wrap:wrap;
      align-items:center;justify-content:space-between
    }
    .kbd{
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      font-size:11px;padding:3px 7px;border-radius:8px;border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.25);color:#cfe0ff
    }

    .panel{
      margin-top:14px;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.12);border-radius:22px;box-shadow:var(--shadow);overflow:hidden
    }
    .panelHeader{
      display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 14px;flex-wrap:wrap;
      background:linear-gradient(90deg,rgba(34,197,94,.18),rgba(59,130,246,.16),rgba(168,85,247,.14));
      border-bottom:1px solid rgba(255,255,255,.10)
    }
    .chip{
      font-size:12px;padding:6px 10px;border-radius:999px;background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12);color:var(--muted);display:inline-flex;align-items:center;gap:8px
    }
    .panelBody{display:grid;grid-template-columns:1.1fr 1fr;gap:12px;padding:12px}
    @media (max-width:860px){.panelBody{grid-template-columns:1fr}}
    .section{background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.10);border-radius:18px;padding:12px}
    .section h2{font-size:13px;margin:0 0 10px;color:#dbe8ff}
    .section p{margin:0 0 10px;font-size:12px;color:var(--muted)}

    .swatches{display:grid;grid-template-columns:repeat(10,1fr);gap:8px}
    .swatch{
      width:100%;aspect-ratio:1/1;border-radius:12px;border:1px solid rgba(255,255,255,.16);cursor:pointer;
      box-shadow:inset 0 0 0 2px rgba(0,0,0,.12),0 6px 14px rgba(0,0,0,.25);
      transition:transform .08s ease,filter .2s ease,outline .2s ease
    }
    .swatch:hover{transform:translateY(-1px);filter:brightness(1.08)}
    .swatch.selected{outline:2px solid rgba(98,255,207,.9);outline-offset:2px}

    .sliders{display:grid;gap:10px;margin-top:10px}
    .row{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .row label{font-size:12px;color:var(--muted)}
    .row input[type="range"]{flex:1}

    .footerRow{
      display:flex;flex-wrap:wrap;gap:10px;justify-content:space-between;align-items:center;
      padding:12px 14px;border-top:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.18);
      color:var(--muted);font-size:12px
    }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="controls">
      <button class="kidbtn b1" id="prevBtn"><span class="emoji">‚¨ÖÔ∏è</span> Back</button>
      <button class="kidbtn b2" id="nextBtn">Next <span class="emoji">‚û°Ô∏è</span></button>

      <button class="kidbtn fxStar" id="starsBtn"><span class="emoji">‚≠ê</span> Stars</button>
      <button class="kidbtn fxGlitter" id="glitterBtn"><span class="emoji">‚ú®</span> Glitter</button>
      <button class="kidbtn fxConfetti" id="confettiBtn"><span class="emoji">üéâ</span> Confetti</button>

      <button class="kidbtn b4" id="undoBtn"><span class="emoji">‚Ü©Ô∏è</span> Oops!</button>
      <button class="kidbtn b5" id="cleanBtn"><span class="emoji">üßº</span> Clean Page</button>
      <button class="kidbtn b6" id="saveBtn"><span class="emoji">üíæ</span> Save</button>

      <div class="toggles">
        <div class="pill">
          <input type="checkbox" id="flashToggle" checked />
          <label for="flashToggle">Flashing Border</label>
        </div>

        <div class="pill">
          <label for="size">Size</label>
          <input id="size" type="range" min="3" max="90" value="28" />
          <span class="kbd" id="sizeVal">28</span>
        </div>
      </div>
    </div>

    <div class="stage" id="stage">
      <div class="canvasWrap">
        <canvas id="canvas" width="1200" height="800"></canvas>
        <div class="smallstatus">
          <div>Tip: Tap Fill colours an area ¬∑ FX mode places ONE stamp each tap</div>
          <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
            <span class="kbd" id="pageLabel">Page 1</span>
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="panelHeader">
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
          <span class="chip">Mode: <b id="modeText">Paint</b></span>
          <span class="chip">Tap Fill: <b id="fillChip">Off</b></span>
          <span class="chip">SFX: <b id="sfxChip">On</b></span>
          <span class="chip">Colour: <span class="kbd" id="currentColour">#2563eb</span></span>
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap;">
          <button class="kidbtn b2" id="fillBtn" style="padding:10px 12px;font-size:13px;"><span class="emoji">ü™£</span> Tap Fill</button>
          <button class="kidbtn b4" id="sfxBtn" style="padding:10px 12px;font-size:13px;"><span class="emoji">üîä</span> SFX: On</button>
          <button class="kidbtn b5" id="eraserBtn" style="padding:10px 12px;font-size:13px;"><span class="emoji">üßΩ</span> Eraser</button>
        </div>
      </div>

      <div class="panelBody">
        <div class="section">
          <h2>üé® Paint Colours</h2>
          <p>Pick a colour for painting + FX tint.</p>
          <div class="swatches" id="colourSwatches"></div>

          <div class="sliders">
            <div class="row">
              <label for="opacity">Opacity</label>
              <input id="opacity" type="range" min="0.05" max="1" value="1" step="0.05" />
              <span class="kbd" id="opacityVal">1.00</span>
            </div>
            <div class="row">
              <label for="smooth">Smoothing</label>
              <input id="smooth" type="range" min="0" max="0.9" value="0.35" step="0.05" />
              <span class="kbd" id="smoothVal">0.35</span>
            </div>
          </div>
        </div>

        <div class="section">
          <h2>‚ú® FX Stamp Controls</h2>
          <p>Use Stars / Glitter / Confetti buttons. Tap to place one stamp.</p>

          <div class="sliders">
            <div class="row">
              <label for="strength">FX Strength</label>
              <input id="strength" type="range" min="0" max="1" value="0.6" step="0.05" />
              <span class="kbd" id="strengthVal">0.60</span>
            </div>
            <div class="row">
              <label for="scatter">FX Scatter</label>
              <input id="scatter" type="range" min="0" max="1" value="0.35" step="0.05" />
              <span class="kbd" id="scatterVal">0.35</span>
            </div>
          </div>
        </div>
      </div>

      <div class="footerRow">
        <div>Undo: <span class="kbd">Ctrl</span>+<span class="kbd">Z</span></div>
        <div>Stars / Glitter / Confetti: tap to place one at a time</div>
      </div>
    </div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    const pages = [
      "colouring images/butterfly.png",
      "colouring images/car.png",
      "colouring images/chest.png",
      "colouring images/dino.png",
      "colouring images/dog.png",
      "colouring images/doll.png",
      "colouring images/house.png",
      "colouring images/kids.png",
      "colouring images/plane.png",
      "colouring images/prince.png",
      "colouring images/swan.png",
      "colouring images/veg.png"
    ];
    let currentPage = 0;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand = (a,b) => Math.random()*(b-a)+a;

    // DPR resize
    function setCanvasSizeForDPR() {
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      const cssW = rect.width;
      const cssH = rect.width * (2/3);
      canvas.style.height = cssH + "px";

      const newW = Math.max(600, Math.round(cssW * dpr));
      const newH = Math.max(400, Math.round(cssH * dpr));

      let snap = null;
      try { snap = ctx.getImageData(0,0,canvas.width,canvas.height); } catch(e){}

      canvas.width = newW;
      canvas.height = newH;

      if (snap) {
        const tmp = document.createElement("canvas");
        tmp.width = snap.width; tmp.height = snap.height;
        tmp.getContext("2d").putImageData(snap,0,0);
        ctx.drawImage(tmp, 0,0, tmp.width,tmp.height, 0,0, canvas.width,canvas.height);
      }
    }

    // Base image
    const baseImage = new Image();
    baseImage.decoding = "async";

    function drawBaseImage() {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0,0,canvas.width,canvas.height);

      const ratio = Math.min(canvas.width/baseImage.naturalWidth, canvas.height/baseImage.naturalHeight);
      const w = Math.round(baseImage.naturalWidth * ratio);
      const h = Math.round(baseImage.naturalHeight * ratio);
      const x = Math.round((canvas.width - w) / 2);
      const y = Math.round((canvas.height - h) / 2);

      ctx.imageSmoothingEnabled = true;
      ctx.imageSmoothingQuality = "high";
      ctx.drawImage(baseImage, x, y, w, h);
    }

    const pageLabel = document.getElementById("pageLabel");
    function loadPage(i){
      currentPage = (i + pages.length) % pages.length;
      pageLabel.textContent = `Page ${currentPage + 1}`;
      baseImage.src = encodeURI(pages[currentPage]);
    }
    baseImage.onload = () => { drawBaseImage(); undoStack.length = 0; };

    // Flash border toggle
    const stage = document.getElementById('stage');
    document.getElementById('flashToggle').addEventListener('change', (e)=>{
      stage.classList.toggle('noflash', !e.target.checked);
    });

    // Undo
    const undoStack = [];
    const MAX_UNDO = 20;
    function pushUndo(){
      try{
        if (undoStack.length >= MAX_UNDO) undoStack.shift();
        undoStack.push(ctx.getImageData(0,0,canvas.width,canvas.height));
      }catch(e){}
    }
    function undo(){
      const last = undoStack.pop();
      if (last) ctx.putImageData(last,0,0);
    }

    // UI values
    const sizeEl = document.getElementById('size');
    const sizeVal = document.getElementById('sizeVal');
    const opacityEl = document.getElementById('opacity');
    const opacityVal = document.getElementById('opacityVal');
    const smoothEl = document.getElementById('smooth');
    const smoothVal = document.getElementById('smoothVal');
    const strengthEl = document.getElementById('strength');
    const strengthVal = document.getElementById('strengthVal');
    const scatterEl = document.getElementById('scatter');
    const scatterVal = document.getElementById('scatterVal');

    let brushSize = parseInt(sizeEl.value,10);
    let brushOpacity = parseFloat(opacityEl.value);
    let smoothing = parseFloat(smoothEl.value);
    let fxStrength = parseFloat(strengthEl.value);
    let fxScatter = parseFloat(scatterEl.value);

    sizeEl.addEventListener('input', ()=>{ brushSize = parseInt(sizeEl.value,10); syncSliders(); });
    opacityEl.addEventListener('input', ()=>{ brushOpacity = parseFloat(opacityEl.value); syncSliders(); });
    smoothEl.addEventListener('input', ()=>{ smoothing = parseFloat(smoothEl.value); syncSliders(); });
    strengthEl.addEventListener('input', ()=>{ fxStrength = parseFloat(strengthEl.value); syncSliders(); });
    scatterEl.addEventListener('input', ()=>{ fxScatter = parseFloat(scatterEl.value); syncSliders(); });

    function syncSliders(){
      sizeVal.textContent = brushSize;
      opacityVal.textContent = brushOpacity.toFixed(2);
      smoothVal.textContent = smoothing.toFixed(2);
      strengthVal.textContent = fxStrength.toFixed(2);
      scatterVal.textContent = fxScatter.toFixed(2);
    }

    // Colour palette
    let brushColour = "#2563eb";
    const currentColourEl = document.getElementById("currentColour");
    const colours = [
      "#000000","#ffffff","#ef4444","#f97316","#facc15",
      "#22c55e","#10b981","#06b6d4","#3b82f6","#6366f1",
      "#a855f7","#ec4899","#f43f5e","#8b5cf6","#14b8a6",
      "#84cc16","#eab308","#fb7185","#60a5fa","#94a3b8"
    ];
    const swatchWrap = document.getElementById("colourSwatches");
    function buildSwatches(){
      swatchWrap.innerHTML = "";
      colours.forEach(c=>{
        const d = document.createElement("div");
        d.className = "swatch" + (c.toLowerCase()===brushColour.toLowerCase() ? " selected" : "");
        d.style.background = c==="#ffffff" ? "linear-gradient(135deg,#fff,#dbeafe)" : c;
        d.addEventListener("click", ()=>{
          brushColour = c;
          isEraser = false;
          eraserBtn.classList.remove("active");
          [...document.querySelectorAll(".swatch")].forEach(x=>x.classList.remove("selected"));
          d.classList.add("selected");
          currentColourEl.textContent = brushColour;
        });
        swatchWrap.appendChild(d);
      });
    }
    currentColourEl.textContent = brushColour;

    // Modes
    const modeText = document.getElementById("modeText");
    let mode = "paint"; // paint | stars | glitter | confetti
    function setMode(m){
      mode = m;
      modeText.textContent =
        (m==="paint") ? "Paint" :
        (m==="stars") ? "Stars" :
        (m==="glitter") ? "Glitter" : "Confetti";

      document.getElementById("starsBtn").classList.toggle("active", m==="stars");
      document.getElementById("glitterBtn").classList.toggle("active", m==="glitter");
      document.getElementById("confettiBtn").classList.toggle("active", m==="confetti");
    }

    document.getElementById("starsBtn").addEventListener("click", ()=>{ isEraser=false; eraserBtn.classList.remove("active"); setMode("stars"); });
    document.getElementById("glitterBtn").addEventListener("click", ()=>{ isEraser=false; eraserBtn.classList.remove("active"); setMode("glitter"); });
    document.getElementById("confettiBtn").addEventListener("click", ()=>{ isEraser=false; eraserBtn.classList.remove("active"); setMode("confetti"); });

    // Eraser
    let isEraser = false;
    const eraserBtn = document.getElementById("eraserBtn");
    eraserBtn.addEventListener("click", ()=>{
      isEraser = !isEraser;
      eraserBtn.classList.toggle("active", isEraser);
      if (isEraser){
        tapFillOn = false;
        updateFillUI();
      }
      if (isEraser) setMode("paint");
    });

    // SFX (pop + brush)
    let sfxOn = true;
    const sfxBtn = document.getElementById("sfxBtn");
    const sfxChip = document.getElementById("sfxChip");
    let audioCtx = null;

    function ensureAudio(){
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") audioCtx.resume();
    }

    // unlock audio on first touch
    canvas.addEventListener("pointerdown", ()=>{ ensureAudio(); }, { once:true });

    sfxBtn.addEventListener("click", ()=>{
      ensureAudio();
      sfxOn = !sfxOn;
      sfxBtn.innerHTML = sfxOn ? '<span class="emoji">üîä</span> SFX: On' : '<span class="emoji">üîá</span> SFX: Off';
      sfxChip.textContent = sfxOn ? "On" : "Off";
    });

    function playPopSfx(kind="glitter"){
      if (!sfxOn) return;
      ensureAudio(); if (!audioCtx) return;

      const t = audioCtx.currentTime;

      // little "pop" pitch per kind
      const base =
        (kind==="stars") ? 880 :
        (kind==="confetti") ? 740 : 820;

      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "triangle";
      o.frequency.setValueAtTime(base, t);
      o.frequency.exponentialRampToValueAtTime(base*1.6, t+0.06);

      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(0.12, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.12);

      o.connect(g); g.connect(audioCtx.destination);
      o.start(t); o.stop(t+0.14);

      // tiny sparkle noise burst
      const nDur = 0.09;
      const bufferSize = Math.max(1, Math.floor(nDur * audioCtx.sampleRate));
      const buf = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i=0;i<bufferSize;i++){
        const env = Math.pow(1 - i/bufferSize, 2);
        data[i] = (Math.random()*2-1) * 0.35 * env;
      }
      const src = audioCtx.createBufferSource();
      src.buffer = buf;

      const bp = audioCtx.createBiquadFilter();
      bp.type = "highpass";
      bp.frequency.setValueAtTime(kind==="confetti" ? 1600 : 2200, t);

      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(0.0001, t);
      ng.gain.linearRampToValueAtTime(kind==="confetti" ? 0.06 : 0.07, t+0.01);
      ng.gain.exponentialRampToValueAtTime(0.0001, t+nDur);

      src.connect(bp); bp.connect(ng); ng.connect(audioCtx.destination);
      src.start(t); src.stop(t+nDur+0.01);
    }

    function playBrushSfx(intensity=1){
      if (!sfxOn) return;
      ensureAudio(); if (!audioCtx) return;

      const bufferSize = 2 * audioCtx.sampleRate;
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const output = noiseBuffer.getChannelData(0);
      for (let i=0;i<bufferSize;i++) output[i] = (Math.random()*2-1) * 0.6;

      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuffer;

      const filter = audioCtx.createBiquadFilter();
      filter.type = "bandpass";
      filter.frequency.value = 1200;
      filter.Q.value = 0.9;

      const gain = audioCtx.createGain();
      const t = audioCtx.currentTime;
      const g = 0.03 * clamp(intensity, 0.2, 2);
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(g, t + 0.01);
      gain.gain.linearRampToValueAtTime(0, t + 0.08);

      noise.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);

      noise.start();
      noise.stop(t + 0.09);
    }

    // Tap Fill
    let tapFillOn = false;
    const fillBtn = document.getElementById("fillBtn");
    const fillChip = document.getElementById("fillChip");
    function updateFillUI(){
      fillBtn.classList.toggle("active", tapFillOn);
      fillChip.textContent = tapFillOn ? "On" : "Off";
    }
    fillBtn.addEventListener("click", ()=>{
      tapFillOn = !tapFillOn;
      if (tapFillOn){
        isEraser = false;
        eraserBtn.classList.remove("active");
      }
      updateFillUI();
    });

    function hexToRgb(hex){
      const v = parseInt(hex.replace("#",""),16);
      return [(v>>16)&255,(v>>8)&255,v&255];
    }
    function luminance(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }
    function colorClose(r,g,b, tr,tg,tb, tol){
      return Math.abs(r-tr)<=tol && Math.abs(g-tg)<=tol && Math.abs(b-tb)<=tol;
    }
    function floodFillTap(x, y, fillHex){
      const w = canvas.width, h = canvas.height;
      if (x<0||y<0||x>=w||y>=h) return [];
      const img = ctx.getImageData(0,0,w,h);
      const d = img.data;
      const i0 = (y*w + x) * 4;

      const tr = d[i0], tg = d[i0+1], tb = d[i0+2], ta = d[i0+3];
      if (ta === 0) return [];
      if (luminance(tr,tg,tb) < 55) return []; // stop on outlines

      const [fr,fg,fb] = hexToRgb(fillHex);
      if (tr===fr && tg===fg && tb===fb) return [];

      const tol = 30;
      const stack = [[x,y]];
      const seen = new Uint8Array(w*h);
      const samples = [];
      const MAX_SAMPLES = 1000;

      const MAX_PIXELS = w*h*0.55;
      let filled = 0;

      while(stack.length){
        const [px,py] = stack.pop();
        if (px<0||py<0||px>=w||py>=h) continue;
        const idx = py*w + px;
        if (seen[idx]) continue;
        seen[idx] = 1;

        const i = idx*4;
        const r = d[i], g = d[i+1], b = d[i+2], a = d[i+3];
        if (a === 0) continue;
        if (luminance(r,g,b) < 55) continue;
        if (!colorClose(r,g,b, tr,tg,tb, tol)) continue;

        d[i] = fr; d[i+1] = fg; d[i+2] = fb; d[i+3] = 255;
        filled++;

        if (samples.length < MAX_SAMPLES) samples.push({x:px, y:py});
        if (filled > MAX_PIXELS) break;

        stack.push([px-1,py],[px+1,py],[px,py-1],[px,py+1]);
      }

      ctx.putImageData(img,0,0);
      return samples;
    }

    // FX drawing helpers
    function hsvToHex(h, s, v){
      const f=(n,k=(n+h/60)%6)=>v - v*s*Math.max(Math.min(k,4-k,1),0);
      const r=Math.round(f(5)*255), g=Math.round(f(3)*255), b=Math.round(f(1)*255);
      return "#"+[r,g,b].map(x=>x.toString(16).padStart(2,"0")).join("");
    }
    function drawStar(x,y,r,fill){
      ctx.save();
      ctx.translate(x,y);
      ctx.beginPath();
      const spikes = 5;
      const outer = r;
      const inner = r*0.45;
      let rot = Math.PI/2 * 3;
      let step = Math.PI / spikes;
      ctx.moveTo(0, -outer);
      for (let i=0;i<spikes;i++){
        ctx.lineTo(Math.cos(rot) * outer, Math.sin(rot) * outer);
        rot += step;
        ctx.lineTo(Math.cos(rot) * inner, Math.sin(rot) * inner);
        rot += step;
      }
      ctx.closePath();
      ctx.fillStyle = fill;
      ctx.fill();
      ctx.restore();
    }

    // ONE TAP = ONE STAMP (with size slider)
    function placeStamp(kind, x, y){
      const base = brushSize * 0.55;         // uses the same size slider
      const strength = fxStrength;
      const scat = fxScatter;

      if (kind === "stars"){
        const starSize = base * (0.8 + strength*1.2);
        // main big star
        ctx.save();
        ctx.globalAlpha = 0.28 + strength*0.60;
        drawStar(x, y, starSize, brushColour === "#ffffff" ? "#fde68a" : brushColour);
        ctx.restore();

        // small twinkles around it (makes it "pop")
        const tw = Math.floor(6 + strength*18);
        ctx.save();
        for (let i=0;i<tw;i++){
          const tx = x + rand(-starSize*1.4, starSize*1.4) * (0.35 + scat);
          const ty = y + rand(-starSize*1.4, starSize*1.4) * (0.35 + scat);
          const r = rand(1.2, 4.0) * (0.7 + strength);
          const c = (i%4===0) ? "#ffffff" : (i%4===1 ? "#fde68a" : (i%4===2 ? "#93c5fd" : "#f9a8d4"));
          ctx.globalAlpha = 0.18 + strength*0.40;
          drawStar(tx,ty,r,c);
        }
        ctx.restore();
        playPopSfx("stars");
        return;
      }

      if (kind === "glitter"){
        // glitter = lots of sparkles in a tight burst
        const count = Math.floor(18 + strength*55);
        ctx.save();
        for (let i=0;i<count;i++){
          const gx = x + rand(-base*2.2, base*2.2) * (0.35 + scat);
          const gy = y + rand(-base*2.2, base*2.2) * (0.35 + scat);
          const gr = rand(0.9, 3.6) * (0.7 + strength);
          const c = (i%3===0) ? "#ffffff" : (i%3===1 ? "#fde68a" : "#a7f3d0");
          ctx.globalAlpha = 0.22 + strength*0.55;
          ctx.fillStyle = c;
          ctx.beginPath(); ctx.arc(gx,gy,gr,0,Math.PI*2); ctx.fill();

          // occasional cross sparkle
          if (i % 10 === 0){
            ctx.globalAlpha = 0.14 + strength*0.28;
            ctx.strokeStyle = c;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(gx-gr*2.3, gy); ctx.lineTo(gx+gr*2.3, gy);
            ctx.moveTo(gx, gy-gr*2.3); ctx.lineTo(gx, gy+gr*2.3);
            ctx.stroke();
          }
        }
        ctx.restore();
        playPopSfx("glitter");
        return;
      }

      if (kind === "confetti"){
        const pieces = Math.floor(14 + strength*40);
        ctx.save();
        for (let i=0;i<pieces;i++){
          const cx = x + rand(-base*2.4, base*2.4) * (0.35 + scat);
          const cy = y + rand(-base*2.4, base*2.4) * (0.35 + scat);
          const w = rand(2, 8) * (0.8 + strength);
          const h = rand(2, 8) * (0.8 + strength);
          const col = hsvToHex((Date.now()/10 + i*37)%360, 0.85, 1);
          ctx.globalAlpha = 0.16 + strength*0.45;
          ctx.fillStyle = col;
          ctx.fillRect(cx, cy, w, h);
        }
        ctx.restore();
        playPopSfx("confetti");
      }
    }

    // Drawing (paint)
    function getPos(e){
      const rect = canvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      return { x:(e.clientX - rect.left) * dpr, y:(e.clientY - rect.top) * dpr };
    }

    function drawPaintSegment(prev, cur){
      const dx = cur.x - prev.x, dy = cur.y - prev.y;
      const dist = Math.hypot(dx,dy);
      const steps = Math.max(1, Math.floor(dist/2));
      ctx.lineCap = "round"; ctx.lineJoin = "round";

      for (let i=0;i<=steps;i++){
        const t = i/steps;
        const x = prev.x + dx*t;
        const y = prev.y + dy*t;

        const r = brushSize * 0.5;

        if (isEraser){
          ctx.save();
          ctx.globalCompositeOperation = "destination-out";
          ctx.globalAlpha = 1;
          ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
          ctx.restore();
        } else {
          ctx.save();
          ctx.globalAlpha = brushOpacity;
          ctx.fillStyle = brushColour;
          ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill();
          ctx.restore();
        }
      }
    }

    // Pointer logic
    let drawing = false;
    let lastPoint = null;

    canvas.addEventListener("pointerdown", (e)=>{
      const p = getPos(e);

      // Tap fill
      if (tapFillOn){
        pushUndo();
        floodFillTap(Math.floor(p.x), Math.floor(p.y), brushColour);
        return;
      }

      // FX stamp modes: ONE TAP = ONE STAMP
      if (!isEraser && (mode==="stars" || mode==="glitter" || mode==="confetti")){
        pushUndo();
        placeStamp(mode, p.x, p.y);
        return;
      }

      // Paint / eraser drag
      drawing = true;
      pushUndo();
      lastPoint = p;
      canvas.setPointerCapture(e.pointerId);
      playBrushSfx(1);
    });

    canvas.addEventListener("pointermove", (e)=>{
      if (!drawing || !lastPoint) return;

      const p = getPos(e);
      const sx = lastPoint.x + (p.x - lastPoint.x) * (1 - smoothing);
      const sy = lastPoint.y + (p.y - lastPoint.y) * (1 - smoothing);
      const smoothP = {x:sx, y:sy};

      drawPaintSegment(lastPoint, smoothP);
      playBrushSfx(clamp(Math.hypot(smoothP.x-lastPoint.x, smoothP.y-lastPoint.y)/18, 0.3, 1.6));
      lastPoint = smoothP;
    });

    function endDraw(e){
      drawing = false;
      lastPoint = null;
      try{ canvas.releasePointerCapture(e.pointerId); }catch(_){}
    }
    canvas.addEventListener("pointerup", endDraw);
    canvas.addEventListener("pointercancel", endDraw);
    canvas.addEventListener("pointerleave", ()=>{ drawing=false; lastPoint=null; });

    // Buttons
    document.getElementById("nextBtn").addEventListener("click", ()=> loadPage(currentPage + 1));
    document.getElementById("prevBtn").addEventListener("click", ()=> loadPage(currentPage - 1));
    document.getElementById("cleanBtn").addEventListener("click", ()=> loadPage(currentPage));
    document.getElementById("undoBtn").addEventListener("click", ()=> undo());
    document.getElementById("saveBtn").addEventListener("click", ()=>{
      const link = document.createElement("a");
      link.download = "my_colouring.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
    });

    window.addEventListener("keydown", (e)=>{
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==="z"){
        e.preventDefault(); undo();
      }
    });

    // Init
    syncSliders();
    buildSwatches();
    updateFillUI();
    setMode("paint");
    setCanvasSizeForDPR();
    loadPage(0);

    window.addEventListener("resize", ()=>{
      setCanvasSizeForDPR();
      loadPage(currentPage);
    });
  </script>
</body>
</html>
