<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Colouring Generator | Salam Adventures</title>
  <style>
    :root{--maxw:1100px;}
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#fafafa;color:#111}
    header{padding:18px 16px;background:#fff;border-bottom:1px solid #eee}
    .wrap{max-width:var(--maxw);margin:0 auto}
    h1{margin:0;font-size:20px}
    p{margin:6px 0 0;color:#444;font-size:14px}
    main{padding:16px}
    .panel{background:#fff;border:1px solid #eee;border-radius:14px;padding:14px;box-shadow:0 4px 18px rgba(0,0,0,.04)}
    .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;margin-bottom:12px}
    select,button,label,input{font-size:14px}
    select{padding:10px;border-radius:10px;border:1px solid #ddd;background:#fff;min-width:240px}
    button{padding:10px 12px;border-radius:10px;border:1px solid #ddd;background:#111;color:#fff;cursor:pointer}
    button.secondary{background:#fff;color:#111}
    button:disabled{opacity:.5;cursor:not-allowed}
    .chip{display:inline-flex;align-items:center;gap:8px;padding:10px 12px;border:1px solid #ddd;border-radius:10px;background:#fff}
    .palette{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
    .swatch{width:26px;height:26px;border-radius:999px;border:2px solid #ddd;cursor:pointer}
    .swatch.active{border-color:#111}
    .stage{display:grid;grid-template-columns:1fr;gap:12px}
    .canvasWrap{border:1px dashed #ddd;border-radius:14px;padding:12px;background:#fcfcfc;overflow:auto}
    canvas{display:block;margin:0 auto;background:#fff;touch-action:none}
    .hint{font-size:12px;color:#555;margin-top:10px}
    .small{font-size:12px;color:#666}
  </style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>Colouring Page Generator</h1>
    <p>Pick a page ‚Üí colour it ‚Üí print or download.</p>
  </div>
</header>

<main class="wrap">
  <div class="panel">
    <div class="controls">
      <select id="picker" aria-label="Choose a colouring page"></select>
      <button id="btnLoad">Load</button>
      <button id="btnRandom" class="secondary">Random</button>

      <select id="sizeMode" aria-label="Size mode">
        <option value="standard" selected>Size: Standard (recommended)</option>
        <option value="fit">Size: Fit (no upscale)</option>
        <option value="fill">Size: Fill (bigger)</option>
      </select>

      <span class="chip" title="Draw on top of the page">
        üñåÔ∏è Brush
        <input id="brushSize" type="range" min="2" max="40" value="10" />
      </span>

      <button id="btnEraser" class="secondary" title="Erase your colouring">Eraser</button>
      <button id="btnFill" class="secondary" title="Tap/click to fill an area">Tap to Fill</button>

      <button id="btnReset" class="secondary" title="Clear colouring and reload page">Reset</button>
      <button id="btnDownload" class="secondary" disabled>Download PNG</button>
      <button id="btnPrint" class="secondary" disabled>Print</button>
    </div>

    <div class="controls">
      <div class="palette" id="palette"></div>
      <span class="small" id="modeLabel">Mode: Brush</span>
    </div>

    <div class="stage">
      <div class="canvasWrap">
        <canvas id="c" width="1240" height="1754" aria-label="Colouring canvas"></canvas>
      </div>
      <div class="hint">
        Tip: ‚ÄúStandard‚Äù makes all pages feel the same size.
        <div class="small" id="status"></div>
      </div>
    </div>
  </div>
</main>

<script>
  const BASE_RAW =
    "https://raw.githubusercontent.com/salamtruthfulltd-alt/salam-adventures-games/main/colouring%20images/";

  const FILES = [
    "butterfly.png.jpg",
    "car.png.jpg",
    "dinosaur.png",
    "dog1.png",
    "dolly.png",
    "flower design.png",
    "fruit and veg.png",
    "garden.png",
    "horse.png",
    "house.png",
    "mobile phone.png",
    "moon (2).png",
    "planes.png",
    "prince and princess.png",
    "swans.png.jpg",
    "tresure chest.png"
  ];

  const picker = document.getElementById("picker");
  const btnLoad = document.getElementById("btnLoad");
  const btnRandom = document.getElementById("btnRandom");
  const btnDownload = document.getElementById("btnDownload");
  const btnPrint = document.getElementById("btnPrint");
  const btnReset = document.getElementById("btnReset");
  const btnEraser = document.getElementById("btnEraser");
  const btnFill = document.getElementById("btnFill");
  const brushSize = document.getElementById("brushSize");
  const paletteEl = document.getElementById("palette");
  const modeLabel = document.getElementById("modeLabel");
  const statusEl = document.getElementById("status");
  const sizeMode = document.getElementById("sizeMode");

  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d", { willReadFrequently: true });

  let baseImageData = null;
  let drawing = false;
  let mode = "brush";
  let color = "#ff3b30";

  const COLORS = [
    "#ff3b30","#ff9500","#ffcc00","#34c759","#00c7be","#007aff",
    "#5856d6","#af52de","#ff2d55","#8e8e93","#000000","#ffffff"
  ];

  function setStatus(msg){ statusEl.textContent = msg || ""; }
  function niceName(file){ return file.replace(/\.(png|jpg|jpeg)$/i, ""); }
  function fileUrl(file){ return BASE_RAW + encodeURIComponent(file); }

  FILES.forEach((f) => {
    const opt = document.createElement("option");
    opt.value = f;
    opt.textContent = niceName(f);
    picker.appendChild(opt);
  });
  picker.value = FILES[0];

  function renderPalette(){
    paletteEl.innerHTML = "";
    COLORS.forEach((c) => {
      const b = document.createElement("button");
      b.className = "swatch" + (c === color ? " active" : "");
      b.style.background = c;
      b.title = c;
      b.addEventListener("click", () => { color = c; renderPalette(); });
      paletteEl.appendChild(b);
    });
  }
  renderPalette();

  function setMode(m){
    mode = m;
    modeLabel.textContent = "Mode: " + (m === "brush" ? "Brush" : m === "eraser" ? "Eraser" : "Tap to Fill");
  }
  btnEraser.addEventListener("click", () => setMode("eraser"));
  btnFill.addEventListener("click", () => setMode("fill"));

  function clearWhite(){
    ctx.save();
    ctx.setTransform(1,0,0,1,0,0);
    ctx.fillStyle = "#fff";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.restore();
  }

  function drawBorder(){
    const margin = Math.round(canvas.width * 0.04);
    ctx.save();
    ctx.lineWidth = Math.max(10, Math.round(canvas.width * 0.008));
    ctx.strokeStyle = "#000";
    ctx.strokeRect(margin, margin, canvas.width - margin*2, canvas.height - margin*2);
    ctx.restore();
    return margin;
  }

  function computeScale(imgW, imgH, innerW, innerH){
    const mode = sizeMode.value;

    // Base "fit" scale (always inside the box)
    const fitScale = Math.min(innerW / imgW, innerH / imgH);

    if (mode === "fit"){
      // no upscaling
      return Math.min(1, fitScale);
    }

    if (mode === "fill"){
      // bigger look: aim to occupy more space (still keep inside)
      const TARGET = 0.92;
      const longSide = Math.max(imgW, imgH);
      const boxLong = Math.max(innerW, innerH);
      let s = (boxLong * TARGET) / longSide;
      // ensure it still fits inside
      s = Math.min(s, fitScale);
      // allow some upscale but cap it
      return Math.min(s, 2.2);
    }

    // STANDARD (recommended): make all images feel same size
    // Target the longest side to be ~82% of the inner box longest side.
    const TARGET = 0.82;
    const longSide = Math.max(imgW, imgH);
    const boxLong = Math.max(innerW, innerH);
    let s = (boxLong * TARGET) / longSide;

    // ensure it stays inside the inner area
    s = Math.min(s, fitScale);

    // allow moderate upscale so small images don't look tiny (but cap it)
    const MAX_UPSCALE = 2.0;
    return Math.min(s, MAX_UPSCALE);
  }

  async function loadAndFit(file){
    btnDownload.disabled = true;
    btnPrint.disabled = true;
    setStatus("Loading: " + file + " ‚Ä¶");

    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = fileUrl(file);

    await new Promise((resolve, reject) => {
      img.onload = resolve;
      img.onerror = () => reject(new Error("Could not load image. Check file name + folder path."));
    });

    clearWhite();
    const margin = drawBorder();

    const PAD = 70;
    const innerX = margin + PAD;
    const innerY = margin + PAD;
    const innerW = canvas.width - (margin + PAD) * 2;
    const innerH = canvas.height - (margin + PAD) * 2;

    const imgW = img.naturalWidth || img.width;
    const imgH = img.naturalHeight || img.height;

    const scale = computeScale(imgW, imgH, innerW, innerH);

    const drawW = Math.round(imgW * scale);
    const drawH = Math.round(imgH * scale);
    const dx = Math.round(innerX + (innerW - drawW) / 2);
    const dy = Math.round(innerY + (innerH - drawH) / 2);

    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = "high";
    ctx.drawImage(img, dx, dy, drawW, drawH);

    baseImageData = ctx.getImageData(0,0,canvas.width,canvas.height);

    btnDownload.disabled = false;
    btnPrint.disabled = false;

    setMode("brush");
    setStatus("Ready: " + niceName(file));
  }

  btnLoad.addEventListener("click", () => loadAndFit(picker.value).catch(e => setStatus("Error: " + e.message)));
  btnRandom.addEventListener("click", () => {
    const r = FILES[Math.floor(Math.random() * FILES.length)];
    picker.value = r;
    loadAndFit(r).catch(e => setStatus("Error: " + e.message));
  });

  sizeMode.addEventListener("change", () => {
    loadAndFit(picker.value).catch(e => setStatus("Error: " + e.message));
  });

  btnReset.addEventListener("click", () => {
    if (!baseImageData) return;
    ctx.putImageData(baseImageData, 0, 0);
    setMode("brush");
  });

  function getPos(e){
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    const x = (clientX - rect.left) * (canvas.width / rect.width);
    const y = (clientY - rect.top) * (canvas.height / rect.height);
    return { x: Math.max(0, Math.min(canvas.width-1, x)), y: Math.max(0, Math.min(canvas.height-1, y)) };
  }

  function startDraw(e){
    if (!baseImageData) return;
    const p = getPos(e);

    if (mode === "fill"){
      floodFill(Math.floor(p.x), Math.floor(p.y), color);
      e.preventDefault();
      return;
    }

    drawing = true;
    ctx.beginPath();
    ctx.moveTo(p.x, p.y);
    e.preventDefault();
  }

  function moveDraw(e){
    if (!drawing) return;
    const p = getPos(e);

    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.lineWidth = Number(brushSize.value);

    if (mode === "eraser"){
      ctx.globalCompositeOperation = "destination-out";
      ctx.strokeStyle = "rgba(0,0,0,1)";
    } else {
      ctx.globalCompositeOperation = "source-over";
      ctx.strokeStyle = color;
    }

    ctx.lineTo(p.x, p.y);
    ctx.stroke();
    e.preventDefault();
  }

  function endDraw(){
    drawing = false;
    ctx.globalCompositeOperation = "source-over";
  }

  canvas.addEventListener("mousedown", startDraw);
  canvas.addEventListener("mousemove", moveDraw);
  window.addEventListener("mouseup", endDraw);

  canvas.addEventListener("touchstart", startDraw, { passive:false });
  canvas.addEventListener("touchmove", moveDraw, { passive:false });
  window.addEventListener("touchend", endDraw);

  function hexToRgba(hex){
    const h = hex.replace("#","").trim();
    const bigint = parseInt(h, 16);
    if (h.length === 6){
      return [(bigint>>16)&255, (bigint>>8)&255, bigint&255, 255];
    }
    return [0,0,0,255];
  }

  function matchColor(data, idx, target, tol=18){
    return (
      Math.abs(data[idx]   - target[0]) <= tol &&
      Math.abs(data[idx+1] - target[1]) <= tol &&
      Math.abs(data[idx+2] - target[2]) <= tol &&
      Math.abs(data[idx+3] - target[3]) <= tol
    );
  }

  function setColor(data, idx, col){
    data[idx] = col[0]; data[idx+1]=col[1]; data[idx+2]=col[2]; data[idx+3]=255;
  }

  function floodFill(x, y, fillHex){
    const img = ctx.getImageData(0,0,canvas.width,canvas.height);
    const data = img.data;
    const w = canvas.width;
    const h = canvas.height;

    const startIdx = (y*w + x) * 4;
    const target = [data[startIdx], data[startIdx+1], data[startIdx+2], data[startIdx+3]];
    const fill = hexToRgba(fillHex);

    const isBlackish = (target[0] < 40 && target[1] < 40 && target[2] < 40);
    const sameAsFill = (target[0]===fill[0] && target[1]===fill[1] && target[2]===fill[2] && target[3]===fill[3]);
    if (isBlackish || sameAsFill) return;

    const stack = [[x,y]];
    const visited = new Uint8Array(w*h);

    while (stack.length){
      const [cx, cy] = stack.pop();
      if (cx<0 || cy<0 || cx>=w || cy>=h) continue;
      const p = cy*w + cx;
      if (visited[p]) continue;
      visited[p] = 1;

      const idx = p*4;

      const r=data[idx], g=data[idx+1], b=data[idx+2], a=data[idx+3];
      if (r < 40 && g < 40 && b < 40 && a > 50) continue;

      if (!matchColor(data, idx, target, 22)) continue;

      setColor(data, idx, fill);
      stack.push([cx+1, cy], [cx-1, cy], [cx, cy+1], [cx, cy-1]);
    }

    ctx.putImageData(img, 0, 0);
  }

  btnDownload.addEventListener("click", () => {
    const a = document.createElement("a");
    a.download = `colouring-${picker.value.replace(/\s+/g,"-")}.png`;
    a.href = canvas.toDataURL("image/png");
    a.click();
  });

  btnPrint.addEventListener("click", () => {
    const dataUrl = canvas.toDataURL("image/png");
    const w = window.open("", "_blank");
    w.document.write(`
      <!doctype html><html><head><meta charset="utf-8" />
      <title>Print</title>
      <style>
        @page { size: A4 portrait; margin: 0.4in; }
        body { margin: 0; }
        img { width: 100%; height: auto; display:block; }
      </style></head><body>
      <img src="${dataUrl}" alt="Colouring Page"/>
      <script>window.onload=()=>{window.print();};<\/script>
      </body></html>
    `);
    w.document.close();
  });

  loadAndFit(picker.value).catch(e => setStatus("Error: " + e.message));
</script>
</body>
</html>
