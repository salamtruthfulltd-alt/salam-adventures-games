<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Salam Adventures ‚Ä¢ Colouring</title>
  <style>
    :root{
      --bg1:#0b1024;
      --bg2:#111a33;
      --panel:#0f1730;
      --panel2:#121d3d;
      --stroke:rgba(255,255,255,.14);
      --stroke2:rgba(255,255,255,.09);
      --txt:#eaf0ff;
      --muted:rgba(234,240,255,.7);
      --shadow:0 18px 60px rgba(0,0,0,.55);
      --round:22px;
      --round2:16px;
    }

    *{box-sizing:border-box}
    body{
      margin:0;
      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
      color:var(--txt);
      background:
        radial-gradient(900px 500px at 20% 10%, rgba(92,189,255,.20), transparent 60%),
        radial-gradient(700px 450px at 80% 20%, rgba(255,152,238,.20), transparent 60%),
        radial-gradient(700px 450px at 40% 85%, rgba(138,255,189,.14), transparent 60%),
        linear-gradient(180deg, var(--bg1), #050816 70%);
      display:flex;
      justify-content:center;
      padding:28px;
    }

    /* Outer frame */
    .app {
      width:min(980px, 96vw);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--stroke);
      border-radius: 28px;
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }

    /* Top toolbar */
    .topbar{
      padding:14px 16px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.01));
      border-bottom:1px solid var(--stroke2);
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      justify-content:center;
    }

    .pill{
      border:1px solid rgba(255,255,255,.16);
      background: rgba(12,18,42,.55);
      color:var(--txt);
      border-radius: 999px;
      padding:10px 14px;
      font-weight:700;
      font-size:14px;
      cursor:pointer;
      transition:.15s transform, .15s filter, .15s opacity;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      box-shadow: inset 0 0 14px rgba(255,255,255,.06);
    }
    .pill:hover{ transform: translateY(-1px); filter:brightness(1.08) }
    .pill:active{ transform: translateY(0px) scale(.99) }
    .pill[disabled]{opacity:.55; cursor:not-allowed}

    /* Gradient candy buttons */
    .b-back{ background:linear-gradient(90deg,#63c7ff,#6a8bff); }
    .b-next{ background:linear-gradient(90deg,#ffd86b,#ff8c6b); color:#1b1020;}
    .b-paint{ background:linear-gradient(90deg,#ff6bd6,#8a7bff);}
    .b-fill{ background:linear-gradient(90deg,#5effa1,#5cc2ff); color:#06131b;}
    .b-erase{ background:linear-gradient(90deg,#ff7b7b,#ffb86b); color:#221105;}
    .b-fx{ background:linear-gradient(90deg,#ffef5c,#ff7bf0); color:#1b1020;}
    .b-undo{ background:linear-gradient(90deg,#7bffef,#7ba2ff); color:#06131b;}
    .b-clear{ background:linear-gradient(90deg,#ff7bf0,#ff7b7b); color:#1b0b12;}
    .b-save{ background:linear-gradient(90deg,#baff6b,#6bffda); color:#06131b;}

    /* Main layout */
    .main{
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:14px;
      padding:14px;
    }

    .left{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--stroke2);
      border-radius: var(--round);
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height: 640px;
    }

    .right{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--stroke2);
      border-radius: var(--round);
      padding:14px;
      min-height: 640px;
    }

    /* Smaller image container (as requested) */
    .canvas-wrap{
      background: linear-gradient(180deg, rgba(5,8,22,.8), rgba(7,10,28,.65));
      border:1px solid rgba(255,255,255,.12);
      border-radius: var(--round);
      padding:12px;
      box-shadow: inset 0 0 22px rgba(0,0,0,.55);
    }

    .canvas-stage{
      width: 420px;       /* smaller */
      height: 420px;      /* smaller */
      margin: 0 auto;
      background:#ffffff;
      border-radius: 16px;
      border: 10px solid rgba(255,255,255,.88);
      box-shadow: 0 18px 45px rgba(0,0,0,.35);
      position:relative;
      overflow:hidden;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    .canvas-stage img{
      width:100%;
      height:100%;
      object-fit:contain;
      display:block;
      pointer-events:none;
      user-select:none;
      position:absolute;
      inset:0;
    }

    canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      touch-action:none;
    }

    .tip{
      font-size:13px;
      color:var(--muted);
      margin-top:10px;
      padding:10px 12px;
      background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
    }

    .statusbar{
      display:flex;
      gap:10px;
      justify-content:space-between;
      align-items:center;
      flex-wrap:wrap;
      margin-top:6px;
      font-size:12.5px;
      color:rgba(234,240,255,.75);
    }

    .badge{
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.20);
    }

    /* Brushes moved UNDER image (as requested) */
    .brushes-container{
      margin-top: 6px;
      padding: 12px;
      background: linear-gradient(145deg, #1e2a4a, #0c122a);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 20px;
      display:flex;
      flex-direction:column;
      gap:10px;
      box-shadow: inset 0 0 12px rgba(255,255,255,0.05);
    }

    .brushes-title{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      color:rgba(234,240,255,.9);
      font-weight:800;
      font-size:13px;
    }

    .brush-row{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      justify-content:center;
    }

    .brush-btn{
      padding: 10px 14px;       /* slightly smaller */
      font-size: 13.5px;
      font-weight:800;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(255,255,255,.06);
      color:var(--txt);
      cursor:pointer;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      transition:.12s transform, .12s filter;
      box-shadow: inset 0 0 14px rgba(255,255,255,.06);
    }
    .brush-btn:hover{ transform: translateY(-1px); filter:brightness(1.08) }
    .brush-btn.active{
      outline: 2px solid rgba(255,255,255,.35);
      background: rgba(255,255,255,.12);
    }

    /* Right panel controls */
    .panel-title{
      font-weight:900;
      letter-spacing:.2px;
      margin:4px 0 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }

    .mini{
      font-size:12px;
      color:var(--muted);
    }

    .row{
      background: rgba(0,0,0,.18);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 16px;
      padding:12px;
      margin-bottom:12px;
    }

    .chips{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
      align-items:center;
      margin-bottom:10px;
    }

    .chip{
      font-size:12px;
      font-weight:800;
      padding:7px 10px;
      border-radius: 999px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: rgba(234,240,255,.9);
    }

    .chip strong{ color:#fff }

    .palette{
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      margin-top:10px;
    }
    .swatch{
      width:34px;
      height:34px;
      border-radius: 10px;
      border:2px solid rgba(255,255,255,.55);
      cursor:pointer;
      box-shadow: 0 10px 25px rgba(0,0,0,.25), inset 0 0 10px rgba(255,255,255,.10);
      position:relative;
    }
    .swatch.active::after{
      content:"";
      position:absolute;
      inset:-4px;
      border-radius: 12px;
      border:2px solid rgba(255,255,255,.95);
      box-shadow: 0 0 0 4px rgba(255,255,255,.15);
    }

    .slider{
      margin-top:10px;
      display:grid;
      gap:10px;
    }
    .slider label{
      display:flex;
      align-items:center;
      justify-content:space-between;
      font-size:12.5px;
      color:rgba(234,240,255,.85);
      gap:10px;
    }
    input[type="range"]{ width:100% }

    .toggle{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-top:10px;
    }
    .toggle button{
      border-radius:999px;
      border:1px solid rgba(255,255,255,.16);
      background: linear-gradient(90deg,#6bffda,#ff7bf0);
      color:#09121f;
      font-weight:900;
      padding:10px 14px;
      cursor:pointer;
      box-shadow: inset 0 0 12px rgba(255,255,255,.22);
    }

    .small-note{
      font-size:12px;
      color:rgba(234,240,255,.68);
      margin-top:8px;
      line-height:1.35;
    }

    /* Responsive */
    @media (max-width: 880px){
      body{ padding:14px; }
      .main{ grid-template-columns: 1fr; }
      .left,.right{ min-height:auto; }
      .canvas-stage{ width:min(420px, 84vw); height:min(420px, 84vw); }
    }
  </style>
</head>
<body>
  <div class="app" role="application" aria-label="Colouring App">
    <!-- TOP CONTROLS (NO BRUSHES HERE ANYMORE) -->
    <div class="topbar">
      <button class="pill b-back" id="btnBack">‚¨ÖÔ∏è Back</button>
      <button class="pill b-next" id="btnNext">Next ‚û°Ô∏è</button>

      <button class="pill b-paint" id="btnModePaint">üñåÔ∏è Paint</button>
      <button class="pill b-fill" id="btnModeFill">ü™£ Fill</button>
      <button class="pill b-erase" id="btnModeErase">üßº Erase</button>
      <button class="pill b-fx" id="btnModeFX">‚ú® FX</button>

      <button class="pill b-undo" id="btnUndo">‚Ü©Ô∏è Undo</button>
      <button class="pill b-clear" id="btnClear">üßΩ Clear</button>
      <button class="pill b-save" id="btnSave">üíæ Save</button>
    </div>

    <div class="main">
      <!-- LEFT: IMAGE + BRUSHES UNDER IMAGE -->
      <div class="left">
        <div class="canvas-wrap">
          <div class="canvas-stage" id="stage">
            <!-- Your lineart (never erased) -->
            <img id="lineart" alt="Colouring Page" src="butterfly.png" />
            <!-- Paint layer (erasing only affects this) -->
            <canvas id="paintLayer"></canvas>
            <!-- FX layer (sparkles etc.) -->
            <canvas id="fxLayer"></canvas>
          </div>

          <div class="tip">
            Tip: <b>Paint</b> = draw ‚Ä¢ <b>Fill</b> = tap an area ‚Ä¢ <b>Erase</b> removes paint only ‚Ä¢ <b>FX</b> adds stars/glitter/confetti.
          </div>

          <div class="statusbar">
            <span class="badge" id="pageBadge">Page 1</span>
            <span class="badge" id="modeBadge">Mode: Paint</span>
          </div>
        </div>

        <!-- BRUSHES MOVED UNDER IMAGE (EMPTY SPACE FILLED) -->
        <div class="brushes-container">
          <div class="brushes-title">
            <span>üß∞ Brushes</span>
            <span class="mini" id="brushBadge">Round</span>
          </div>

          <div class="brush-row" id="brushRow">
            <button class="brush-btn active" data-brush="round">‚óè Round</button>
            <button class="brush-btn" data-brush="square">‚ñ† Square</button>
            <button class="brush-btn" data-brush="triangle">‚ñ≤ Triangle</button>
            <button class="brush-btn" data-brush="spray">üå´Ô∏è Spray</button>
            <button class="brush-btn" data-brush="star">‚≠ê Star</button>
            <button class="brush-btn" data-brush="glitter">‚ú® Glitter</button>
            <button class="brush-btn" data-brush="multi">üåà Multi</button>
          </div>

          <div class="small-note">
            Brush affects Paint mode. FX mode uses the FX selector (Stars/Glitter/Confetti) on the right.
          </div>
        </div>
      </div>

      <!-- RIGHT: COLOURS + SLIDERS + FX -->
      <div class="right">
        <div class="panel-title">
          <span>Controls</span>
          <span class="mini">Colour ‚Ä¢ Size ‚Ä¢ Opacity ‚Ä¢ Smooth</span>
        </div>

        <div class="row">
          <div class="chips">
            <span class="chip">Colour: <strong id="chipColour">#ff4d6d</strong></span>
            <span class="chip">Brush: <strong id="chipBrush">Round</strong></span>
            <span class="chip">FX: <strong id="chipFX">Stars</strong></span>
          </div>

          <div class="toggle">
            <span class="chip">SFX: <strong id="chipSFX">On</strong></span>
            <button id="btnSFX">üîä SFX</button>
          </div>

          <div class="small-note">Pick a colour (paint + tint for some FX).</div>

          <div class="palette" id="palette"></div>

          <div class="slider">
            <label>
              <span>Size</span>
              <span id="valSize">16</span>
            </label>
            <input id="size" type="range" min="4" max="60" value="16"/>

            <label>
              <span>Opacity</span>
              <span id="valOpacity">0.90</span>
            </label>
            <input id="opacity" type="range" min="0.1" max="1" step="0.05" value="0.9"/>

            <label>
              <span>Smooth</span>
              <span id="valSmooth">0.55</span>
            </label>
            <input id="smooth" type="range" min="0" max="0.9" step="0.05" value="0.55"/>
          </div>
        </div>

        <div class="row">
          <div class="panel-title" style="margin:0 0 8px">
            <span>‚ú® FX Mode</span>
            <span class="mini">Tap to drop effects</span>
          </div>

          <div class="chips" id="fxChips">
            <button class="brush-btn active" data-fx="stars">‚ú® Stars</button>
            <button class="brush-btn" data-fx="glitter">üíé Glitter</button>
            <button class="brush-btn" data-fx="confetti">üéâ Confetti</button>
          </div>

          <div class="small-note">
            In FX mode: tap to place effects. They gently twinkle automatically.
          </div>
        </div>

        <div class="row">
          <div class="panel-title" style="margin:0 0 8px">
            <span>Pages</span>
            <span class="mini">Replace images here</span>
          </div>
          <div class="small-note">
            This demo uses: <b>butterfly.png</b>. Add more pages in the <code>pages[]</code> array in the script.
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---------- Simple SFX (tiny beeps) ----------
    let sfxOn = true;
    const beep = (freq=660, dur=0.06, type="sine", vol=0.045) => {
      if(!sfxOn) return;
      try{
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.type = type;
        o.frequency.value = freq;
        g.gain.value = vol;
        o.connect(g); g.connect(ctx.destination);
        o.start();
        o.stop(ctx.currentTime + dur);
        o.onended = () => ctx.close();
      }catch(e){}
    };

    // ---------- Elements ----------
    const stage = document.getElementById('stage');
    const img = document.getElementById('lineart');

    const paint = document.getElementById('paintLayer');
    const fx = document.getElementById('fxLayer');
    const pctx = paint.getContext('2d');
    const fctx = fx.getContext('2d');

    const modeBadge = document.getElementById('modeBadge');
    const pageBadge = document.getElementById('pageBadge');

    const chipColour = document.getElementById('chipColour');
    const chipBrush = document.getElementById('chipBrush');
    const chipFX = document.getElementById('chipFX');
    const chipSFX = document.getElementById('chipSFX');

    // Top buttons
    const btnBack = document.getElementById('btnBack');
    const btnNext = document.getElementById('btnNext');
    const btnModePaint = document.getElementById('btnModePaint');
    const btnModeFill = document.getElementById('btnModeFill');
    const btnModeErase = document.getElementById('btnModeErase');
    const btnModeFX = document.getElementById('btnModeFX');
    const btnUndo = document.getElementById('btnUndo');
    const btnClear = document.getElementById('btnClear');
    const btnSave = document.getElementById('btnSave');

    // Right controls
    const paletteEl = document.getElementById('palette');
    const sizeEl = document.getElementById('size');
    const opacityEl = document.getElementById('opacity');
    const smoothEl = document.getElementById('smooth');
    const valSize = document.getElementById('valSize');
    const valOpacity = document.getElementById('valOpacity');
    const valSmooth = document.getElementById('valSmooth');

    const btnSFX = document.getElementById('btnSFX');

    // Brush row (under image)
    const brushRow = document.getElementById('brushRow');
    const brushBadge = document.getElementById('brushBadge');

    // FX chips (right)
    const fxChips = document.getElementById('fxChips');

    // ---------- App State ----------
    const pages = [
      "butterfly.png"
      // Add more like: "star.png", "balloon.png", "salam.png"
    ];
    let pageIndex = 0;

    let mode = "paint"; // paint | fill | erase | fx
    let brush = "round"; // round | square | triangle | spray | star | glitter | multi
    let fxMode = "stars"; // stars | glitter | confetti

    let colour = "#ff4d6d";
    let brushSize = parseInt(sizeEl.value, 10);
    let opacity = parseFloat(opacityEl.value);
    let smooth = parseFloat(smoothEl.value);

    // Undo stacks (paint + fx)
    const undoStack = [];
    const maxUndo = 30;

    // FX particles store
    const fxParticles = [];

    // ---------- Helpers ----------
    function setMode(m){
      mode = m;
      modeBadge.textContent = "Mode: " + (m[0].toUpperCase() + m.slice(1));
      beep(m === "erase" ? 240 : 660, 0.06, "triangle");
    }

    function setBrush(b){
      brush = b;
      brushBadge.textContent = b[0].toUpperCase() + b.slice(1);
      chipBrush.textContent = brushLabel(b);
      beep(520, 0.05, "sine");
    }

    function brushLabel(b){
      const map = {round:"Round", square:"Square", triangle:"Triangle", spray:"Spray", star:"Star", glitter:"Glitter", multi:"Multi"};
      return map[b] || "Round";
    }

    function setFX(f){
      fxMode = f;
      chipFX.textContent = f[0].toUpperCase() + f.slice(1);
      beep(780, 0.05, "sine");
    }

    function setColour(c){
      colour = c;
      chipColour.textContent = c.toLowerCase();
    }

    function resizeCanvases(){
      const rect = stage.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      [paint, fx].forEach(cv=>{
        cv.width = Math.round(rect.width * dpr);
        cv.height = Math.round(rect.height * dpr);
        cv.style.width = rect.width + "px";
        cv.style.height = rect.height + "px";
        cv.getContext('2d').setTransform(dpr,0,0,dpr,0,0);
      });

      // keep paint crisp
      pctx.lineCap = "round";
      pctx.lineJoin = "round";
    }

    function snapshot(){
      // Save both layers for undo
      try{
        const p = paint.toDataURL("image/png");
        const f = fx.toDataURL("image/png");
        undoStack.push({p, f, fxParticles: JSON.parse(JSON.stringify(fxParticles))});
        if(undoStack.length > maxUndo) undoStack.shift();
      }catch(e){}
    }

    function restoreSnap(snap){
      if(!snap) return;
      // Restore paint
      const ip = new Image();
      ip.onload = ()=>{
        pctx.clearRect(0,0,paint.width,paint.height);
        pctx.drawImage(ip, 0,0, paint.width/(window.devicePixelRatio||1), paint.height/(window.devicePixelRatio||1));
      };
      ip.src = snap.p;

      // Restore fx
      const iff = new Image();
      iff.onload = ()=>{
        fctx.clearRect(0,0,fx.width,fx.height);
        fctx.drawImage(iff, 0,0, fx.width/(window.devicePixelRatio||1), fx.height/(window.devicePixelRatio||1));
      };
      iff.src = snap.f;

      // Restore particles
      fxParticles.length = 0;
      snap.fxParticles.forEach(x=>fxParticles.push(x));
    }

    function clearAll(){
      snapshot();
      pctx.clearRect(0,0,paint.width,paint.height);
      fctx.clearRect(0,0,fx.width,fx.height);
      fxParticles.length = 0;
      beep(180,0.08,"square");
    }

    function undo(){
      if(undoStack.length === 0) return;
      const snap = undoStack.pop();
      restoreSnap(snap);
      beep(320,0.06,"triangle");
    }

    function loadPage(i){
      pageIndex = Math.max(0, Math.min(pages.length-1, i));
      img.src = pages[pageIndex];
      pageBadge.textContent = `Page ${pageIndex+1}`;
      // Clear layers for new page
      pctx.clearRect(0,0,paint.width,paint.height);
      fctx.clearRect(0,0,fx.width,fx.height);
      fxParticles.length = 0;
      undoStack.length = 0;
      beep(720,0.06,"sine");
      btnBack.disabled = pageIndex === 0;
      btnNext.disabled = pageIndex === pages.length-1;
    }

    // ---------- Palette ----------
    const colours = [
      "#000000","#ffffff","#ff3b30","#ff9500","#ffcc00","#34c759","#00c7be","#007aff",
      "#5856d6","#af52de","#ff2d55","#ff6b6b","#8a7bff","#00d4ff","#ffd86b","#baff6b",
      "#ff7bf0","#6bffda","#6a8bff","#ff8c6b","#9ea7b8","#3a3f55"
    ];

    function buildPalette(){
      paletteEl.innerHTML = "";
      colours.forEach(c=>{
        const s = document.createElement("div");
        s.className = "swatch" + (c.toLowerCase()===colour.toLowerCase() ? " active" : "");
        s.style.background = c;
        s.title = c;
        s.addEventListener("click", ()=>{
          document.querySelectorAll(".swatch").forEach(x=>x.classList.remove("active"));
          s.classList.add("active");
          setColour(c);
          beep(900,0.04,"sine");
        });
        paletteEl.appendChild(s);
      });
    }

    // ---------- Drawing ----------
    let drawing = false;
    let last = null;

    function getPos(e){
      const rect = stage.getBoundingClientRect();
      const t = (e.touches && e.touches[0]) ? e.touches[0] : e;
      return { x: t.clientX - rect.left, y: t.clientY - rect.top };
    }

    function lerp(a,b,t){ return a + (b-a)*t; }

    function drawStroke(from, to){
      const steps = Math.max(1, Math.floor(Math.hypot(to.x-from.x, to.y-from.y) / 2));
      for(let i=0;i<=steps;i++){
        const t = i/steps;
        const x = lerp(from.x, to.x, t);
        const y = lerp(from.y, to.y, t);
        stampPaint(x,y);
      }
    }

    function stampPaint(x,y){
      const ctx = pctx;
      ctx.save();
      ctx.globalAlpha = opacity;

      if(mode === "erase"){
        ctx.globalCompositeOperation = "destination-out";
      } else {
        ctx.globalCompositeOperation = "source-over";
      }

      const r = brushSize/2;

      if(brush === "round" || mode === "erase"){
        ctx.fillStyle = colour;
        ctx.beginPath();
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.fill();
      }
      else if(brush === "square"){
        ctx.fillStyle = colour;
        ctx.fillRect(x-r, y-r, brushSize, brushSize);
      }
      else if(brush === "triangle"){
        ctx.fillStyle = colour;
        ctx.beginPath();
        ctx.moveTo(x, y-r);
        ctx.lineTo(x+r, y+r);
        ctx.lineTo(x-r, y+r);
        ctx.closePath();
        ctx.fill();
      }
      else if(brush === "spray"){
        ctx.fillStyle = colour;
        for(let i=0;i<18;i++){
          const a = Math.random()*Math.PI*2;
          const rr = Math.random()*r;
          ctx.fillRect(x + Math.cos(a)*rr, y + Math.sin(a)*rr, 1.6, 1.6);
        }
      }
      else if(brush === "star"){
        ctx.fillStyle = colour;
        drawStar(ctx, x, y, r, Math.max(4, r*0.55), 5);
      }
      else if(brush === "glitter"){
        // glitter: multistamp sparkles around point
        for(let i=0;i<8;i++){
          const a = Math.random()*Math.PI*2;
          const rr = Math.random()*r;
          const cx = x + Math.cos(a)*rr;
          const cy = y + Math.sin(a)*rr;
          ctx.fillStyle = colour;
          drawStar(ctx, cx, cy, Math.max(2, r*0.35), Math.max(1, r*0.18), 5);
        }
      }
      else if(brush === "multi"){
        // rainbow multi
        const rainbow = ["#ff3b30","#ff9500","#ffcc00","#34c759","#00c7be","#007aff","#5856d6","#af52de"];
        ctx.fillStyle = rainbow[Math.floor(Math.random()*rainbow.length)];
        ctx.beginPath();
        ctx.arc(x,y,r,0,Math.PI*2);
        ctx.fill();
      }

      ctx.restore();
    }

    function drawStar(ctx, x, y, outerR, innerR, points){
      ctx.beginPath();
      const step = Math.PI / points;
      for(let i=0;i<2*points;i++){
        const r = (i%2===0)? outerR : innerR;
        const a = i*step - Math.PI/2;
        ctx.lineTo(x + Math.cos(a)*r, y + Math.sin(a)*r);
      }
      ctx.closePath();
      ctx.fill();
    }

    // ---------- Fill (simple flood fill on paint layer only) ----------
    function hexToRgba(hex, a=1){
      const h = hex.replace("#","");
      const v = parseInt(h.length===3 ? h.split("").map(c=>c+c).join("") : h, 16);
      return { r:(v>>16)&255, g:(v>>8)&255, b:v&255, a: Math.round(a*255) };
    }

    function floodFill(x,y){
      snapshot();

      const w = paint.width/(window.devicePixelRatio||1);
      const h = paint.height/(window.devicePixelRatio||1);

      // Read paint layer only (so you fill empty zones without touching lineart image)
      const imgData = pctx.getImageData(0,0,w,h);
      const data = imgData.data;

      const ix = Math.floor(x);
      const iy = Math.floor(y);
      const idx = (iy*w + ix)*4;

      const target = { r:data[idx], g:data[idx+1], b:data[idx+2], a:data[idx+3] };
      const fill = hexToRgba(colour, opacity);

      // If target already close to fill, return
      if (Math.abs(target.r-fill.r)<3 && Math.abs(target.g-fill.g)<3 && Math.abs(target.b-fill.b)<3 && Math.abs(target.a-fill.a)<3){
        return;
      }

      const stack = [[ix,iy]];
      const seen = new Uint8Array(w*h);

      const match = (i)=>{
        return data[i]===target.r && data[i+1]===target.g && data[i+2]===target.b && data[i+3]===target.a;
      };

      while(stack.length){
        const [cx,cy] = stack.pop();
        if(cx<0||cy<0||cx>=w||cy>=h) continue;
        const si = cy*w + cx;
        if(seen[si]) continue;
        seen[si]=1;

        const di = si*4;
        if(!match(di)) continue;

        data[di]=fill.r; data[di+1]=fill.g; data[di+2]=fill.b; data[di+3]=fill.a;

        stack.push([cx+1,cy],[cx-1,cy],[cx,cy+1],[cx,cy-1]);
      }

      pctx.putImageData(imgData,0,0);
      beep(520,0.07,"sine");
    }

    // ---------- FX ----------
    function addFX(x,y){
      snapshot();
      const base = {
        x, y,
        size: Math.max(10, brushSize*0.9),
        born: performance.now(),
        life: 2500 + Math.random()*1200,
        hue: Math.random()*360,
        alpha: 0.9
      };

      if(fxMode === "stars"){
        fxParticles.push({ ...base, type:"star", spin:(Math.random()*2-1)*0.012 });
        beep(880,0.05,"triangle");
      }
      else if(fxMode === "glitter"){
        for(let i=0;i<8;i++){
          fxParticles.push({
            ...base,
            x: x + (Math.random()*2-1)*18,
            y: y + (Math.random()*2-1)*18,
            size: Math.max(6, base.size*0.45),
            type:"spark",
            spin:(Math.random()*2-1)*0.02
          });
        }
        beep(980,0.05,"sine");
      }
      else if(fxMode === "confetti"){
        for(let i=0;i<16;i++){
          fxParticles.push({
            ...base,
            x: x + (Math.random()*2-1)*12,
            y: y + (Math.random()*2-1)*12,
            size: Math.max(6, base.size*0.35),
            type:"confetti",
            vx: (Math.random()*2-1)*0.7,
            vy: -0.9 - Math.random()*0.8,
            spin:(Math.random()*2-1)*0.06
          });
        }
        beep(700,0.05,"square");
      }
    }

    function renderFX(t){
      const w = fx.width/(window.devicePixelRatio||1);
      const h = fx.height/(window.devicePixelRatio||1);
      fctx.clearRect(0,0,w,h);

      for(let i=fxParticles.length-1;i>=0;i--){
        const p = fxParticles[i];
        const age = t - p.born;
        const u = age / p.life;
        if(u >= 1){
          fxParticles.splice(i,1);
          continue;
        }

        const fade = 1 - u;
        const tw = 0.6 + 0.4*Math.sin((age/120) + i);
        const a = Math.max(0, p.alpha * fade * tw);

        fctx.save();
        fctx.globalAlpha = a;

        // subtle color tint using chosen paint colour sometimes
        const usePaint = (Math.random() < 0.6);
        const c = usePaint ? colour : `hsl(${p.hue} 90% 65%)`;
        fctx.fillStyle = c;

        if(p.type === "star"){
          fctx.translate(p.x, p.y);
          fctx.rotate(age * p.spin);
          drawStar(fctx, 0, 0, p.size*0.55, p.size*0.25, 5);
        }
        else if(p.type === "spark"){
          fctx.translate(p.x, p.y);
          fctx.rotate(age * p.spin);
          drawStar(fctx, 0, 0, p.size*0.55, p.size*0.15, 6);
        }
        else if(p.type === "confetti"){
          // motion
          p.x += p.vx;
          p.y += p.vy;
          p.vy += 0.03; // gravity
          fctx.translate(p.x, p.y);
          fctx.rotate(age * p.spin);
          fctx.fillRect(-p.size/2, -p.size/2, p.size, Math.max(4, p.size*0.45));
        }

        fctx.restore();
      }

      requestAnimationFrame(renderFX);
    }

    // ---------- Pointer events ----------
    function onDown(e){
      const pos = getPos(e);
      if(mode === "paint" || mode === "erase"){
        snapshot();
        drawing = true;
        last = pos;
        stampPaint(pos.x, pos.y);
        beep(mode==="erase"?220:740, 0.03, "sine", 0.03);
      } else if(mode === "fill"){
        floodFill(pos.x, pos.y);
      } else if(mode === "fx"){
        addFX(pos.x, pos.y);
      }
    }

    function onMove(e){
      if(!drawing) return;
      const pos = getPos(e);

      // smoothing
      const sx = lerp(last.x, pos.x, 1 - smooth);
      const sy = lerp(last.y, pos.y, 1 - smooth);

      drawStroke(last, {x:sx, y:sy});
      last = {x:sx, y:sy};
    }

    function onUp(){
      drawing = false;
      last = null;
    }

    // Attach
    stage.addEventListener("pointerdown", onDown);
    stage.addEventListener("pointermove", onMove);
    window.addEventListener("pointerup", onUp);
    window.addEventListener("pointercancel", onUp);

    // Touch prevention scroll
    stage.addEventListener("touchstart", (e)=>e.preventDefault(), {passive:false});
    stage.addEventListener("touchmove", (e)=>e.preventDefault(), {passive:false});

    // ---------- Buttons ----------
    btnModePaint.onclick = ()=> setMode("paint");
    btnModeFill.onclick  = ()=> setMode("fill");
    btnModeErase.onclick = ()=> setMode("erase");
    btnModeFX.onclick    = ()=> setMode("fx");

    btnUndo.onclick = undo;
    btnClear.onclick = clearAll;

    btnBack.onclick = ()=> loadPage(pageIndex-1);
    btnNext.onclick = ()=> loadPage(pageIndex+1);

    btnSFX.onclick = ()=>{
      sfxOn = !sfxOn;
      chipSFX.textContent = sfxOn ? "On" : "Off";
      beep(600,0.05,"sine");
    };

    btnSave.onclick = ()=>{
      // Save merged: lineart image + paint + fx
      const rect = stage.getBoundingClientRect();
      const out = document.createElement("canvas");
      out.width = Math.round(rect.width * (window.devicePixelRatio||1));
      out.height = Math.round(rect.height * (window.devicePixelRatio||1));
      const octx = out.getContext("2d");

      // Draw white base
      octx.fillStyle = "#ffffff";
      octx.fillRect(0,0,out.width,out.height);

      // Draw lineart image
      // We draw the image scaled to stage size (same as displayed)
      // Use stage size in CSS pixels:
      const w = rect.width;
      const h = rect.height;
      // Convert to output coords:
      const dpr = window.devicePixelRatio||1;
      octx.setTransform(dpr,0,0,dpr,0,0);
      octx.drawImage(img, 0,0, w, h);
      octx.drawImage(paint, 0,0, w, h);
      octx.drawImage(fx, 0,0, w, h);

      const a = document.createElement("a");
      a.download = `colouring-page-${pageIndex+1}.png`;
      a.href = out.toDataURL("image/png");
      a.click();
      beep(980,0.07,"triangle");
    };

    // ---------- Brush buttons (under image) ----------
    brushRow.addEventListener("click", (e)=>{
      const btn = e.target.closest(".brush-btn");
      if(!btn) return;
      const b = btn.getAttribute("data-brush");
      document.querySelectorAll("#brushRow .brush-btn").forEach(x=>x.classList.remove("active"));
      btn.classList.add("active");
      setBrush(b);
      chipBrush.textContent = brushLabel(b);
    });

    // ---------- FX selector chips ----------
    fxChips.addEventListener("click", (e)=>{
      const btn = e.target.closest(".brush-btn");
      if(!btn) return;
      const f = btn.getAttribute("data-fx");
      document.querySelectorAll("#fxChips .brush-btn").forEach(x=>x.classList.remove("active"));
      btn.classList.add("active");
      setFX(f);
    });

    // ---------- Sliders ----------
    function syncSliders(){
      brushSize = parseInt(sizeEl.value, 10);
      opacity = parseFloat(opacityEl.value);
      smooth = parseFloat(smoothEl.value);
      valSize.textContent = brushSize;
      valOpacity.textContent = opacity.toFixed(2);
      valSmooth.textContent = smooth.toFixed(2);
    }

    sizeEl.oninput = ()=>{ syncSliders(); };
    opacityEl.oninput = ()=>{ syncSliders(); };
    smoothEl.oninput = ()=>{ syncSliders(); };

    // ---------- Init ----------
    function init(){
      resizeCanvases();
      buildPalette();
      syncSliders();
      setColour(colour);
      chipBrush.textContent = "Round";
      chipFX.textContent = "Stars";
      chipSFX.textContent = "On";
      loadPage(0);
      requestAnimationFrame(renderFX);
    }

    window.addEventListener("resize", ()=>{
      // When resizing, keep current drawings by snapshotting images then redrawing after resize
      const pData = paint.toDataURL("image/png");
      const fData = fx.toDataURL("image/png");

      resizeCanvases();

      const ip = new Image();
      ip.onload = ()=>{
        pctx.clearRect(0,0,paint.width,paint.height);
        pctx.drawImage(ip,0,0, stage.clientWidth, stage.clientHeight);
      };
      ip.src = pData;

      const iff = new Image();
      iff.onload = ()=>{
        fctx.clearRect(0,0,fx.width,fx.height);
        fctx.drawImage(iff,0,0, stage.clientWidth, stage.clientHeight);
      };
      iff.src = fData;
    });

    img.addEventListener("load", ()=> {
      // ensure canvases match stage
      resizeCanvases();
    });

    init();
  </script>
</body>
</html>
