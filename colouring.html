<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Salam Adventures ‚Äì Colouring Game</title>
  <style>
    :root{--bg1:#0b1220;--text:#e9f2ff;--muted:#b9c7e6;--shadow:0 12px 30px rgba(0,0,0,.35);}
    html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;color:var(--text);
      background:radial-gradient(1200px 700px at 20% 10%,#203a7a 0%,var(--bg1) 55%,#070b14 100%);}
    *{box-sizing:border-box}
    .wrap{max-width:1100px;margin:18px auto 30px;padding:14px}

    .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:center;justify-content:center;margin-bottom:12px}
    .kidbtn{
      border:none;border-radius:18px;padding:12px 14px;cursor:pointer;font-weight:800;letter-spacing:.2px;color:#0b1220;
      box-shadow:var(--shadow);display:flex;align-items:center;gap:10px;user-select:none;
      transition:transform .08s ease,filter .2s ease;font-size:14px
    }
    .kidbtn:hover{transform:translateY(-1px);filter:brightness(1.05)}
    .kidbtn:active{transform:translateY(0) scale(.99)}
    .kidbtn .emoji{font-size:18px;line-height:1}
    .kidbtn.active{outline:3px solid rgba(98,255,207,.9);outline-offset:2px}

    .b1{background:linear-gradient(135deg,#60a5fa,#34d399)}
    .b2{background:linear-gradient(135deg,#fbbf24,#fb7185)}
    .b4{background:linear-gradient(135deg,#34d399,#fbbf24)}
    .b5{background:linear-gradient(135deg,#fb7185,#a78bfa)}
    .b6{background:linear-gradient(135deg,#fbbf24,#60a5fa)}

    .fxStar{background:linear-gradient(135deg,#fde68a,#60a5fa)}
    .fxGlitter{background:linear-gradient(135deg,#a7f3d0,#f472b6)}
    .fxConfetti{background:linear-gradient(135deg,#fb7185,#fbbf24)}
    .modePaint{background:linear-gradient(135deg,#60a5fa,#a78bfa)}
    .modeFill{background:linear-gradient(135deg,#22c55e,#fbbf24)}

    .toggles{display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:center;width:100%}
    .pill{
      display:flex;align-items:center;gap:10px;padding:10px 12px;border-radius:999px;
      background:rgba(0,0,0,.28);border:1px solid rgba(255,255,255,.14);box-shadow:var(--shadow);
      color:var(--muted);font-size:12px
    }
    .pill input{accent-color:#22c55e}
    .pill input[type="range"]{width:170px}

    .stage{margin-top:10px;border-radius:24px;padding:12px;position:relative;box-shadow:0 20px 60px rgba(0,0,0,.45);overflow:hidden}
    .stage::before{
      content:"";position:absolute;inset:-2px;border-radius:26px;z-index:0;opacity:1;
      background:conic-gradient(from 0deg,#ff3d3d,#ffd93d,#3dff6a,#3ddcff,#7c3dff,#ff3d3d);
      animation:spin 2.8s linear infinite,pulse 1.1s ease-in-out infinite
    }
    .stage::after{
      content:"";position:absolute;inset:6px;border-radius:20px;z-index:0;
      background:linear-gradient(180deg,rgba(10,20,45,.86),rgba(6,10,20,.88))
    }
    .stage.noflash::before{animation:none;opacity:.35}
    @keyframes spin{to{transform:rotate(360deg)}}
    @keyframes pulse{0%,100%{filter:brightness(1)saturate(1.2)}50%{filter:brightness(1.25)saturate(1.8)}}

    .canvasWrap{
      position:relative;z-index:1;padding:10px;border-radius:18px;background:rgba(255,255,255,.03);
      border:1px solid rgba(255,255,255,.10);box-shadow:inset 0 0 0 1px rgba(0,0,0,.15)
    }
    /* Two-layer canvas: bg = image (locked), fg = paint/fx (erasable) */
    .stack{
      position:relative;
      width:100%;
      border-radius:16px;
      overflow:hidden;
      background:#fff;
      touch-action:none;
    }
    canvas{
      display:block;
      width:100%;
      height:auto;
      background:transparent;
      border-radius:16px;
      touch-action:none;
    }
    #bgCanvas{position:relative; z-index:1; pointer-events:none; background:#fff;}
    #fgCanvas{position:absolute; inset:0; z-index:2; background:transparent;}

    .smallstatus{
      margin:10px 6px 0;font-size:12px;color:var(--muted);display:flex;gap:10px;flex-wrap:wrap;
      align-items:center;justify-content:space-between
    }
    .kbd{
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
      font-size:11px;padding:3px 7px;border-radius:8px;border:1px solid rgba(255,255,255,.14);
      background:rgba(0,0,0,.25);color:#cfe0ff
    }

    .panel{
      margin-top:14px;background:linear-gradient(180deg,rgba(255,255,255,.06),rgba(255,255,255,.02));
      border:1px solid rgba(255,255,255,.12);border-radius:22px;box-shadow:var(--shadow);overflow:hidden
    }
    .panelHeader{
      display:flex;align-items:center;justify-content:space-between;gap:12px;padding:12px 14px;flex-wrap:wrap;
      background:linear-gradient(90deg,rgba(34,197,94,.18),rgba(59,130,246,.16),rgba(168,85,247,.14));
      border-bottom:1px solid rgba(255,255,255,.10)
    }
    .chip{
      font-size:12px;padding:6px 10px;border-radius:999px;background:rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.12);color:var(--muted);display:inline-flex;align-items:center;gap:8px
    }
    .panelBody{display:grid;grid-template-columns:1.1fr 1fr;gap:12px;padding:12px}
    @media (max-width:860px){.panelBody{grid-template-columns:1fr}}
    .section{background:rgba(0,0,0,.25);border:1px solid rgba(255,255,255,.10);border-radius:18px;padding:12px}
    .section h2{font-size:13px;margin:0 0 10px;color:#dbe8ff}
    .section p{margin:0 0 10px;font-size:12px;color:var(--muted)}

    .swatches{display:grid;grid-template-columns:repeat(10,1fr);gap:8px}
    .swatch{
      width:100%;aspect-ratio:1/1;border-radius:12px;border:1px solid rgba(255,255,255,.16);cursor:pointer;
      box-shadow:inset 0 0 0 2px rgba(0,0,0,.12),0 6px 14px rgba(0,0,0,.25);
      transition:transform .08s ease,filter .2s ease,outline .2s ease
    }
    .swatch:hover{transform:translateY(-1px);filter:brightness(1.08)}
    .swatch.selected{outline:2px solid rgba(98,255,207,.9);outline-offset:2px}

    .sliders{display:grid;gap:10px;margin-top:10px}
    .row{display:flex;align-items:center;justify-content:space-between;gap:10px}
    .row label{font-size:12px;color:var(--muted)}
    .row input[type="range"]{flex:1}

    .footerRow{
      display:flex;flex-wrap:wrap;gap:10px;justify-content:space-between;align-items:center;
      padding:12px 14px;border-top:1px solid rgba(255,255,255,.10);background:rgba(0,0,0,.18);
      color:var(--muted);font-size:12px
    }
  </style>
</head>

<body>
  <div class="wrap">

    <div class="controls">
      <button class="kidbtn b1" id="prevBtn"><span class="emoji">‚¨ÖÔ∏è</span> Back</button>
      <button class="kidbtn b2" id="nextBtn">Next <span class="emoji">‚û°Ô∏è</span></button>

      <!-- NEW: clear modes -->
      <button class="kidbtn modePaint active" id="paintBtn"><span class="emoji">üñåÔ∏è</span> Paint</button>
      <button class="kidbtn modeFill" id="fillModeBtn"><span class="emoji">ü™£</span> Fill</button>

      <button class="kidbtn fxStar" id="starsBtn"><span class="emoji">‚≠ê</span> Stars</button>
      <button class="kidbtn fxGlitter" id="glitterBtn"><span class="emoji">‚ú®</span> Glitter</button>
      <button class="kidbtn fxConfetti" id="confettiBtn"><span class="emoji">üéâ</span> Confetti</button>

      <button class="kidbtn b4" id="undoBtn"><span class="emoji">‚Ü©Ô∏è</span> Oops!</button>
      <button class="kidbtn b5" id="cleanBtn"><span class="emoji">üßº</span> Clean Page</button>
      <button class="kidbtn b6" id="saveBtn"><span class="emoji">üíæ</span> Save</button>

      <div class="toggles">
        <div class="pill">
          <input type="checkbox" id="flashToggle" checked />
          <label for="flashToggle">Flashing Border</label>
        </div>
        <div class="pill">
          <label for="size">Size</label>
          <input id="size" type="range" min="3" max="90" value="28" />
          <span class="kbd" id="sizeVal">28</span>
        </div>
      </div>
    </div>

    <div class="stage" id="stage">
      <div class="canvasWrap">
        <div class="stack" id="stack">
          <canvas id="bgCanvas" width="1200" height="800" aria-hidden="true"></canvas>
          <canvas id="fgCanvas" width="1200" height="800" aria-label="Colouring layer"></canvas>
        </div>
        <div class="smallstatus">
          <div>Paint = draw ¬∑ Fill = tap an area ¬∑ FX = tap to place one stamp ¬∑ Eraser removes ONLY paint/FX</div>
          <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
            <span class="kbd" id="pageLabel">Page 1</span>
          </div>
        </div>
      </div>
    </div>

    <div class="panel">
      <div class="panelHeader">
        <div style="display:flex;gap:10px;flex-wrap:wrap;align-items:center;">
          <span class="chip">Mode: <b id="modeText">Paint</b></span>
          <span class="chip">SFX: <b id="sfxChip">On</b></span>
          <span class="chip">Colour: <span class="kbd" id="currentColour">#2563eb</span></span>
        </div>
        <div style="display:flex;gap:10px;flex-wrap:wrap;">
          <button class="kidbtn b4" id="sfxBtn" style="padding:10px 12px;font-size:13px;"><span class="emoji">üîä</span> SFX: On</button>
          <button class="kidbtn b5" id="eraserBtn" style="padding:10px 12px;font-size:13px;"><span class="emoji">üßΩ</span> Eraser</button>
        </div>
      </div>

      <div class="panelBody">
        <div class="section">
          <h2>üé® Paint Colours</h2>
          <p>Pick a colour for painting + FX tint.</p>
          <div class="swatches" id="colourSwatches"></div>

          <div class="sliders">
            <div class="row">
              <label for="opacity">Opacity</label>
              <input id="opacity" type="range" min="0.05" max="1" value="1" step="0.05" />
              <span class="kbd" id="opacityVal">1.00</span>
            </div>
            <div class="row">
              <label for="smooth">Smoothing</label>
              <input id="smooth" type="range" min="0" max="0.9" value="0.35" step="0.05" />
              <span class="kbd" id="smoothVal">0.35</span>
            </div>
          </div>
        </div>

        <div class="section">
          <h2>‚ú® FX Stamp Controls</h2>
          <p>Stars / Glitter / Confetti: tap to place one stamp.</p>

          <div class="sliders">
            <div class="row">
              <label for="strength">FX Strength</label>
              <input id="strength" type="range" min="0" max="1" value="0.6" step="0.05" />
              <span class="kbd" id="strengthVal">0.60</span>
            </div>
            <div class="row">
              <label for="scatter">FX Scatter</label>
              <input id="scatter" type="range" min="0" max="1" value="0.35" step="0.05" />
              <span class="kbd" id="scatterVal">0.35</span>
            </div>
          </div>
        </div>
      </div>

      <div class="footerRow">
        <div>Undo: <span class="kbd">Ctrl</span>+<span class="kbd">Z</span></div>
        <div>Eraser is safe: it never deletes the picture</div>
      </div>
    </div>
  </div>

  <script>
    // ====== CANVASES (bg locked image, fg paint/fx/erasable) ======
    const bgCanvas = document.getElementById('bgCanvas');
    const fgCanvas = document.getElementById('fgCanvas');
    const bg = bgCanvas.getContext('2d', { willReadFrequently: true });
    const fg = fgCanvas.getContext('2d', { willReadFrequently: true });

    const pages = [
      "colouring images/butterfly.png",
      "colouring images/car.png",
      "colouring images/chest.png",
      "colouring images/dino.png",
      "colouring images/dog.png",
      "colouring images/doll.png",
      "colouring images/house.png",
      "colouring images/kids.png",
      "colouring images/plane.png",
      "colouring images/prince.png",
      "colouring images/swan.png",
      "colouring images/veg.png"
    ];
    let currentPage = 0;

    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rand = (a,b) => Math.random()*(b-a)+a;

    // DPR resize (keep bg+fg matched)
    function setCanvasSizeForDPR() {
      const stack = document.getElementById("stack");
      const rect = stack.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      const cssW = rect.width;
      const cssH = rect.width * (2/3);

      // set the wrapper height so canvases size correctly
      stack.style.height = cssH + "px";

      const newW = Math.max(600, Math.round(cssW * dpr));
      const newH = Math.max(400, Math.round(cssH * dpr));

      // snapshot fg only
      let fgSnap = null;
      try { fgSnap = fg.getImageData(0,0,fgCanvas.width,fgCanvas.height); } catch(e){}

      bgCanvas.width = newW; bgCanvas.height = newH;
      fgCanvas.width = newW; fgCanvas.height = newH;

      // redraw base image + restore fg
      if (baseImage.complete && baseImage.naturalWidth) drawBaseImage();
      if (fgSnap) {
        const tmp = document.createElement("canvas");
        tmp.width = fgSnap.width; tmp.height = fgSnap.height;
        tmp.getContext("2d").putImageData(fgSnap,0,0);
        fg.drawImage(tmp, 0,0, tmp.width,tmp.height, 0,0, fgCanvas.width,fgCanvas.height);
      }
    }

    // Base image on bg canvas
    const baseImage = new Image();
    baseImage.decoding = "async";

    function drawBaseImage() {
      bg.clearRect(0,0,bgCanvas.width,bgCanvas.height);
      bg.fillStyle = "#ffffff";
      bg.fillRect(0,0,bgCanvas.width,bgCanvas.height);

      const ratio = Math.min(bgCanvas.width/baseImage.naturalWidth, bgCanvas.height/baseImage.naturalHeight);
      const w = Math.round(baseImage.naturalWidth * ratio);
      const h = Math.round(baseImage.naturalHeight * ratio);
      const x = Math.round((bgCanvas.width - w) / 2);
      const y = Math.round((bgCanvas.height - h) / 2);

      bg.imageSmoothingEnabled = true;
      bg.imageSmoothingQuality = "high";
      bg.drawImage(baseImage, x, y, w, h);
    }

    // Clear paint layer
    function clearPaintLayer(){
      fg.clearRect(0,0,fgCanvas.width,fgCanvas.height);
    }

    const pageLabel = document.getElementById("pageLabel");
    function loadPage(i){
      currentPage = (i + pages.length) % pages.length;
      pageLabel.textContent = `Page ${currentPage + 1}`;
      baseImage.src = encodeURI(pages[currentPage]);
    }
    baseImage.onload = () => { drawBaseImage(); clearPaintLayer(); undoStack.length = 0; };

    // Flash border
    const stage = document.getElementById('stage');
    document.getElementById('flashToggle').addEventListener('change', (e)=>{
      stage.classList.toggle('noflash', !e.target.checked);
    });

    // Undo (fg only!)
    const undoStack = [];
    const MAX_UNDO = 25;
    function pushUndo(){
      try{
        if (undoStack.length >= MAX_UNDO) undoStack.shift();
        undoStack.push(fg.getImageData(0,0,fgCanvas.width,fgCanvas.height));
      }catch(e){}
    }
    function undo(){
      const last = undoStack.pop();
      if (last) fg.putImageData(last,0,0);
    }

    // UI values
    const sizeEl = document.getElementById('size');
    const sizeVal = document.getElementById('sizeVal');
    const opacityEl = document.getElementById('opacity');
    const opacityVal = document.getElementById('opacityVal');
    const smoothEl = document.getElementById('smooth');
    const smoothVal = document.getElementById('smoothVal');
    const strengthEl = document.getElementById('strength');
    const strengthVal = document.getElementById('strengthVal');
    const scatterEl = document.getElementById('scatter');
    const scatterVal = document.getElementById('scatterVal');

    let brushSize = parseInt(sizeEl.value,10);
    let brushOpacity = parseFloat(opacityEl.value);
    let smoothing = parseFloat(smoothEl.value);
    let fxStrength = parseFloat(strengthEl.value);
    let fxScatter = parseFloat(scatterEl.value);

    function syncSliders(){
      sizeVal.textContent = brushSize;
      opacityVal.textContent = brushOpacity.toFixed(2);
      smoothVal.textContent = smoothing.toFixed(2);
      strengthVal.textContent = fxStrength.toFixed(2);
      scatterVal.textContent = fxScatter.toFixed(2);
    }
    sizeEl.addEventListener('input', ()=>{ brushSize = parseInt(sizeEl.value,10); syncSliders(); });
    opacityEl.addEventListener('input', ()=>{ brushOpacity = parseFloat(opacityEl.value); syncSliders(); });
    smoothEl.addEventListener('input', ()=>{ smoothing = parseFloat(smoothEl.value); syncSliders(); });
    strengthEl.addEventListener('input', ()=>{ fxStrength = parseFloat(strengthEl.value); syncSliders(); });
    scatterEl.addEventListener('input', ()=>{ fxScatter = parseFloat(scatterEl.value); syncSliders(); });

    // Colours
    let brushColour = "#2563eb";
    const currentColourEl = document.getElementById("currentColour");
    const colours = [
      "#000000","#ffffff","#ef4444","#f97316","#facc15",
      "#22c55e","#10b981","#06b6d4","#3b82f6","#6366f1",
      "#a855f7","#ec4899","#f43f5e","#8b5cf6","#14b8a6",
      "#84cc16","#eab308","#fb7185","#60a5fa","#94a3b8"
    ];
    const swatchWrap = document.getElementById("colourSwatches");
    function buildSwatches(){
      swatchWrap.innerHTML = "";
      colours.forEach(c=>{
        const d = document.createElement("div");
        d.className = "swatch" + (c.toLowerCase()===brushColour.toLowerCase() ? " selected" : "");
        d.style.background = c==="#ffffff" ? "linear-gradient(135deg,#fff,#dbeafe)" : c;
        d.addEventListener("click", ()=>{
          brushColour = c;
          isEraser = false;
          eraserBtn.classList.remove("active");
          [...document.querySelectorAll(".swatch")].forEach(x=>x.classList.remove("selected"));
          d.classList.add("selected");
          currentColourEl.textContent = brushColour;
        });
        swatchWrap.appendChild(d);
      });
    }
    currentColourEl.textContent = brushColour;

    // ====== MODES (clear buttons: Paint vs Fill; FX separate) ======
    const modeText = document.getElementById("modeText");
    let mode = "paint"; // paint | fill | stars | glitter | confetti
    function setMode(m){
      mode = m;
      modeText.textContent =
        (m==="paint") ? "Paint" :
        (m==="fill") ? "Fill" :
        (m==="stars") ? "Stars" :
        (m==="glitter") ? "Glitter" : "Confetti";

      // button highlights
      paintBtn.classList.toggle("active", m==="paint");
      fillModeBtn.classList.toggle("active", m==="fill");
      starsBtn.classList.toggle("active", m==="stars");
      glitterBtn.classList.toggle("active", m==="glitter");
      confettiBtn.classList.toggle("active", m==="confetti");
    }

    const paintBtn = document.getElementById("paintBtn");
    const fillModeBtn = document.getElementById("fillModeBtn");
    const starsBtn = document.getElementById("starsBtn");
    const glitterBtn = document.getElementById("glitterBtn");
    const confettiBtn = document.getElementById("confettiBtn");

    paintBtn.addEventListener("click", ()=>{ isEraser=false; eraserBtn.classList.remove("active"); setMode("paint"); });
    fillModeBtn.addEventListener("click", ()=>{ isEraser=false; eraserBtn.classList.remove("active"); setMode("fill"); });
    starsBtn.addEventListener("click", ()=>{ isEraser=false; eraserBtn.classList.remove("active"); setMode("stars"); });
    glitterBtn.addEventListener("click", ()=>{ isEraser=false; eraserBtn.classList.remove("active"); setMode("glitter"); });
    confettiBtn.addEventListener("click", ()=>{ isEraser=false; eraserBtn.classList.remove("active"); setMode("confetti"); });

    // Eraser (FG only)
    let isEraser = false;
    const eraserBtn = document.getElementById("eraserBtn");
    eraserBtn.addEventListener("click", ()=>{
      isEraser = !isEraser;
      eraserBtn.classList.toggle("active", isEraser);
      if (isEraser) setMode("paint"); // keep it simple: eraser works in paint mode
    });

    // ====== SFX ======
    let sfxOn = true;
    const sfxBtn = document.getElementById("sfxBtn");
    const sfxChip = document.getElementById("sfxChip");
    let audioCtx = null;

    function ensureAudio(){
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") audioCtx.resume();
    }
    fgCanvas.addEventListener("pointerdown", ()=>{ ensureAudio(); }, { once:true });

    sfxBtn.addEventListener("click", ()=>{
      ensureAudio();
      sfxOn = !sfxOn;
      sfxBtn.innerHTML = sfxOn ? '<span class="emoji">üîä</span> SFX: On' : '<span class="emoji">üîá</span> SFX: Off';
      sfxChip.textContent = sfxOn ? "On" : "Off";
    });

    function playPopSfx(kind="glitter"){
      if (!sfxOn) return;
      ensureAudio(); if (!audioCtx) return;

      const t = audioCtx.currentTime;
      const base = (kind==="stars") ? 880 : (kind==="confetti") ? 740 : 820;

      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = "triangle";
      o.frequency.setValueAtTime(base, t);
      o.frequency.exponentialRampToValueAtTime(base*1.6, t+0.06);
      g.gain.setValueAtTime(0.0001, t);
      g.gain.linearRampToValueAtTime(0.12, t+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, t+0.12);
      o.connect(g); g.connect(audioCtx.destination);
      o.start(t); o.stop(t+0.14);

      const nDur = 0.09;
      const bufferSize = Math.max(1, Math.floor(nDur * audioCtx.sampleRate));
      const buf = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const data = buf.getChannelData(0);
      for (let i=0;i<bufferSize;i++){
        const env = Math.pow(1 - i/bufferSize, 2);
        data[i] = (Math.random()*2-1) * 0.35 * env;
      }
      const src = audioCtx.createBufferSource();
      src.buffer = buf;
      const hp = audioCtx.createBiquadFilter();
      hp.type = "highpass";
      hp.frequency.setValueAtTime(kind==="confetti" ? 1600 : 2200, t);
      const ng = audioCtx.createGain();
      ng.gain.setValueAtTime(0.0001, t);
      ng.gain.linearRampToValueAtTime(kind==="confetti" ? 0.06 : 0.07, t+0.01);
      ng.gain.exponentialRampToValueAtTime(0.0001, t+nDur);
      src.connect(hp); hp.connect(ng); ng.connect(audioCtx.destination);
      src.start(t); src.stop(t+nDur+0.01);
    }

    function playBrushSfx(intensity=1){
      if (!sfxOn) return;
      ensureAudio(); if (!audioCtx) return;

      const bufferSize = 2 * audioCtx.sampleRate;
      const noiseBuffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
      const output = noiseBuffer.getChannelData(0);
      for (let i=0;i<bufferSize;i++) output[i] = (Math.random()*2-1) * 0.6;

      const noise = audioCtx.createBufferSource();
      noise.buffer = noiseBuffer;

      const filter = audioCtx.createBiquadFilter();
      filter.type = "bandpass";
      filter.frequency.value = 1200;
      filter.Q.value = 0.9;

      const gain = audioCtx.createGain();
      const t = audioCtx.currentTime;
      const gg = 0.03 * clamp(intensity, 0.2, 2);
      gain.gain.setValueAtTime(0, t);
      gain.gain.linearRampToValueAtTime(gg, t + 0.01);
      gain.gain.linearRampToValueAtTime(0, t + 0.08);

      noise.connect(filter);
      filter.connect(gain);
      gain.connect(audioCtx.destination);

      noise.start();
      noise.stop(t + 0.09);
    }

    // ====== FILL (uses BG image as boundaries, writes fill onto FG only) ======
    function hexToRgb(hex){
      const v = parseInt(hex.replace("#",""),16);
      return [(v>>16)&255,(v>>8)&255,v&255];
    }
    function luminance(r,g,b){ return 0.2126*r + 0.7152*g + 0.0722*b; }
    function colorClose(r,g,b, tr,tg,tb, tol){
      return Math.abs(r-tr)<=tol && Math.abs(g-tg)<=tol && Math.abs(b-tb)<=tol;
    }

    function floodFillFromBG_toFG(x, y, fillHex){
      const w = bgCanvas.width, h = bgCanvas.height;
      if (x<0||y<0||x>=w||y>=h) return;

      // read BG pixels for region detection
      const bgImg = bg.getImageData(0,0,w,h);
      const bd = bgImg.data;

      const i0 = (y*w + x) * 4;
      const tr = bd[i0], tg = bd[i0+1], tb = bd[i0+2], ta = bd[i0+3];
      if (ta === 0) return;
      if (luminance(tr,tg,tb) < 55) return; // don't fill on outlines

      const [fr,fgc,fbc] = hexToRgb(fillHex);

      // We'll write ONLY onto FG layer
      const fgImg = fg.getImageData(0,0,w,h);
      const fd = fgImg.data;

      const tol = 30;
      const stack = [[x,y]];
      const seen = new Uint8Array(w*h);

      const MAX_PIXELS = w*h*0.6;
      let filled = 0;

      while(stack.length){
        const [px,py] = stack.pop();
        if (px<0||py<0||px>=w||py>=h) continue;
        const idx = py*w + px;
        if (seen[idx]) continue;
        seen[idx] = 1;

        const bi = idx*4;
        const r = bd[bi], g = bd[bi+1], b = bd[bi+2], a = bd[bi+3];
        if (a === 0) continue;

        // boundaries: dark pixels in BG are "lines"
        if (luminance(r,g,b) < 55) continue;

        // same region as start (bg-based)
        if (!colorClose(r,g,b, tr,tg,tb, tol)) continue;

        // paint onto FG
        const fi = bi;
        fd[fi] = fr; fd[fi+1] = fgc; fd[fi+2] = fbc; fd[fi+3] = 255;
        filled++;
        if (filled > MAX_PIXELS) break;

        stack.push([px-1,py],[px+1,py],[px,py-1],[px,py+1]);
      }

      fg.putImageData(fgImg,0,0);
    }

    // ====== FX STAMPS (FG only) ======
    function hsvToHex(h, s, v){
      const f=(n,k=(n+h/60)%6)=>v - v*s*Math.max(Math.min(k,4-k,1),0);
      const r=Math.round(f(5)*255), g=Math.round(f(3)*255), b=Math.round(f(1)*255);
      return "#"+[r,g,b].map(x=>x.toString(16).padStart(2,"0")).join("");
    }
    function drawStar(x,y,r,fill){
      fg.save();
      fg.translate(x,y);
      fg.beginPath();
      const spikes=5, outer=r, inner=r*0.45;
      let rot=Math.PI/2*3, step=Math.PI/spikes;
      fg.moveTo(0,-outer);
      for(let i=0;i<spikes;i++){
        fg.lineTo(Math.cos(rot)*outer,Math.sin(rot)*outer); rot+=step;
        fg.lineTo(Math.cos(rot)*inner,Math.sin(rot)*inner); rot+=step;
      }
      fg.closePath();
      fg.fillStyle=fill;
      fg.fill();
      fg.restore();
    }
    function placeStamp(kind, x, y){
      const base = brushSize * 0.55;
      const strength = fxStrength;
      const scat = fxScatter;

      if (kind === "stars"){
        const starSize = base * (0.8 + strength*1.2);
        fg.save();
        fg.globalAlpha = 0.28 + strength*0.60;
        drawStar(x,y,starSize, brushColour === "#ffffff" ? "#fde68a" : brushColour);
        fg.restore();

        const tw = Math.floor(6 + strength*18);
        fg.save();
        for (let i=0;i<tw;i++){
          const tx = x + rand(-starSize*1.4, starSize*1.4) * (0.35 + scat);
          const ty = y + rand(-starSize*1.4, starSize*1.4) * (0.35 + scat);
          const rr = rand(1.2, 4.0) * (0.7 + strength);
          const c = (i%4===0) ? "#ffffff" : (i%4===1 ? "#fde68a" : (i%4===2 ? "#93c5fd" : "#f9a8d4"));
          fg.globalAlpha = 0.18 + strength*0.40;
          drawStar(tx,ty,rr,c);
        }
        fg.restore();
        playPopSfx("stars");
        return;
      }

      if (kind === "glitter"){
        const count = Math.floor(18 + strength*55);
        fg.save();
        for (let i=0;i<count;i++){
          const gx = x + rand(-base*2.2, base*2.2) * (0.35 + scat);
          const gy = y + rand(-base*2.2, base*2.2) * (0.35 + scat);
          const gr = rand(0.9, 3.6) * (0.7 + strength);
          const c = (i%3===0) ? "#ffffff" : (i%3===1 ? "#fde68a" : "#a7f3d0");
          fg.globalAlpha = 0.22 + strength*0.55;
          fg.fillStyle = c;
          fg.beginPath(); fg.arc(gx,gy,gr,0,Math.PI*2); fg.fill();
          if (i % 10 === 0){
            fg.globalAlpha = 0.14 + strength*0.28;
            fg.strokeStyle = c;
            fg.lineWidth = 1;
            fg.beginPath();
            fg.moveTo(gx-gr*2.3, gy); fg.lineTo(gx+gr*2.3, gy);
            fg.moveTo(gx, gy-gr*2.3); fg.lineTo(gx, gy+gr*2.3);
            fg.stroke();
          }
        }
        fg.restore();
        playPopSfx("glitter");
        return;
      }

      if (kind === "confetti"){
        const pieces = Math.floor(14 + strength*40);
        fg.save();
        for (let i=0;i<pieces;i++){
          const cx = x + rand(-base*2.4, base*2.4) * (0.35 + scat);
          const cy = y + rand(-base*2.4, base*2.4) * (0.35 + scat);
          const w = rand(2, 8) * (0.8 + strength);
          const h = rand(2, 8) * (0.8 + strength);
          const col = hsvToHex((Date.now()/10 + i*37)%360, 0.85, 1);
          fg.globalAlpha = 0.16 + strength*0.45;
          fg.fillStyle = col;
          fg.fillRect(cx, cy, w, h);
        }
        fg.restore();
        playPopSfx("confetti");
      }
    }

    // ====== PAINT / ERASER DRAWING (FG only) ======
    function getPos(e){
      const rect = fgCanvas.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;
      return { x:(e.clientX - rect.left) * dpr, y:(e.clientY - rect.top) * dpr };
    }
    function drawPaintSegment(prev, cur){
      const dx = cur.x - prev.x, dy = cur.y - prev.y;
      const dist = Math.hypot(dx,dy);
      const steps = Math.max(1, Math.floor(dist/2));
      fg.lineCap = "round"; fg.lineJoin = "round";

      for (let i=0;i<=steps;i++){
        const t = i/steps;
        const x = prev.x + dx*t;
        const y = prev.y + dy*t;
        const r = brushSize * 0.5;

        if (isEraser){
          fg.save();
          fg.globalCompositeOperation = "destination-out";
          fg.globalAlpha = 1;
          fg.beginPath(); fg.arc(x,y,r,0,Math.PI*2); fg.fill();
          fg.restore();
        } else {
          fg.save();
          fg.globalCompositeOperation = "source-over";
          fg.globalAlpha = brushOpacity;
          fg.fillStyle = brushColour;
          fg.beginPath(); fg.arc(x,y,r,0,Math.PI*2); fg.fill();
          fg.restore();
        }
      }
    }

    // ====== POINTER LOGIC (on FG canvas) ======
    let drawing = false;
    let lastPoint = null;

    fgCanvas.addEventListener("pointerdown", (e)=>{
      const p = getPos(e);

      // Fill mode
      if (mode === "fill"){
        pushUndo();
        floodFillFromBG_toFG(Math.floor(p.x), Math.floor(p.y), brushColour);
        return;
      }

      // FX modes: one tap = one stamp
      if (!isEraser && (mode==="stars" || mode==="glitter" || mode==="confetti")){
        pushUndo();
        placeStamp(mode, p.x, p.y);
        return;
      }

      // Paint/eraser drag
      drawing = true;
      pushUndo();
      lastPoint = p;
      fgCanvas.setPointerCapture(e.pointerId);
      playBrushSfx(1);
    });

    fgCanvas.addEventListener("pointermove", (e)=>{
      if (!drawing || !lastPoint) return;
      const p = getPos(e);
      const sx = lastPoint.x + (p.x - lastPoint.x) * (1 - smoothing);
      const sy = lastPoint.y + (p.y - lastPoint.y) * (1 - smoothing);
      const smoothP = {x:sx, y:sy};

      drawPaintSegment(lastPoint, smoothP);
      playBrushSfx(clamp(Math.hypot(smoothP.x-lastPoint.x, smoothP.y-lastPoint.y)/18, 0.3, 1.6));
      lastPoint = smoothP;
    });

    function endDraw(e){
      drawing = false;
      lastPoint = null;
      try{ fgCanvas.releasePointerCapture(e.pointerId); }catch(_){}
    }
    fgCanvas.addEventListener("pointerup", endDraw);
    fgCanvas.addEventListener("pointercancel", endDraw);
    fgCanvas.addEventListener("pointerleave", ()=>{ drawing=false; lastPoint=null; });

    // ====== Buttons ======
    document.getElementById("nextBtn").addEventListener("click", ()=> loadPage(currentPage + 1));
    document.getElementById("prevBtn").addEventListener("click", ()=> loadPage(currentPage - 1));
    document.getElementById("cleanBtn").addEventListener("click", ()=> { drawBaseImage(); clearPaintLayer(); undoStack.length = 0; });
    document.getElementById("undoBtn").addEventListener("click", ()=> undo());

    document.getElementById("saveBtn").addEventListener("click", ()=>{
      // Export combined (bg + fg) as one PNG
      const out = document.createElement("canvas");
      out.width = bgCanvas.width; out.height = bgCanvas.height;
      const octx = out.getContext("2d");
      octx.drawImage(bgCanvas,0,0);
      octx.drawImage(fgCanvas,0,0);
      const link = document.createElement("a");
      link.download = "my_colouring.png";
      link.href = out.toDataURL("image/png");
      link.click();
    });

    window.addEventListener("keydown", (e)=>{
      if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==="z"){
        e.preventDefault(); undo();
      }
    });

    // ====== Init ======
    syncSliders();
    buildSwatches();
    setMode("paint");
    setCanvasSizeForDPR();
    loadPage(0);

    window.addEventListener("resize", ()=>{
      setCanvasSizeForDPR();
      // keep current page visible
      if (baseImage.complete && baseImage.naturalWidth) drawBaseImage();
    });
  </script>
</body>
</html>
