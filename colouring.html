<script>
/* =========================================================
   SALAM COLOURING GAME â€“ STABLE VERSION
   Paint + Tap Fill + Blank Mode
   DOES NOT BREAK FRAMEWORK
========================================================= */

const canvas = document.getElementById('canvas');
const ctx = canvas.getContext('2d', { willReadFrequently: true });

/* ---------------- CANVAS SAFE SIZE ---------------- */

function setCanvasSizeForDPR() {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;

  const cssW = rect.width;
  const cssH = rect.width * (2/3);

  canvas.style.height = cssH + "px";

  canvas.width = Math.round(cssW * dpr);
  canvas.height = Math.round(cssH * dpr);
}

setCanvasSizeForDPR();
window.addEventListener("resize", () => {
  setCanvasSizeForDPR();
  if (gameMode !== "blank") loadPage(currentPage);
});

/* ---------------- IMAGE PAGES ---------------- */

const pages = [
  "colouring images/butterfly.png",
  "colouring images/car.png",
  "colouring images/chest.png",
  "colouring images/dino.png",
  "colouring images/dog.png",
  "colouring images/doll.png",
  "colouring images/house.png",
  "colouring images/kids.png",
  "colouring images/plane.png",
  "colouring images/prince.png",
  "colouring images/swan.png",
  "colouring images/veg.png"
];

let currentPage = 0;
let gameMode = "paint"; // paint | fill | blank
const baseImage = new Image();
baseImage.crossOrigin = "anonymous";

function drawBaseImage() {
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const ratio = Math.min(
    canvas.width / baseImage.naturalWidth,
    canvas.height / baseImage.naturalHeight
  );

  const w = baseImage.naturalWidth * ratio;
  const h = baseImage.naturalHeight * ratio;
  const x = (canvas.width - w) / 2;
  const y = (canvas.height - h) / 2;

  ctx.drawImage(baseImage, x, y, w, h);
}

function loadPage(index) {
  currentPage = (index + pages.length) % pages.length;
  baseImage.src = encodeURI(pages[currentPage]);
}

baseImage.onload = () => drawBaseImage();

/* ---------------- MODE BAR ---------------- */

const modeBar = document.createElement("div");
modeBar.style.display = "flex";
modeBar.style.gap = "10px";
modeBar.style.justifyContent = "center";
modeBar.style.marginBottom = "10px";

modeBar.innerHTML = `
<button class="kidbtn b1">ðŸ–Œ Paint</button>
<button class="kidbtn b2">ðŸª£ Tap Fill</button>
<button class="kidbtn b3">ðŸ“„ Blank</button>
`;

document.querySelector(".wrap").prepend(modeBar);

modeBar.children[0].onclick = () => gameMode = "paint";
modeBar.children[1].onclick = () => gameMode = "fill";
modeBar.children[2].onclick = () => {
  gameMode = "blank";
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = "#ffffff";
  ctx.fillRect(0,0,canvas.width,canvas.height);
};

/* ---------------- UNDO ---------------- */

const undoStack = [];
function pushUndo(){
  try{
    undoStack.push(ctx.getImageData(0,0,canvas.width,canvas.height));
    if (undoStack.length > 20) undoStack.shift();
  }catch(e){}
}
function undo(){
  const last = undoStack.pop();
  if(last) ctx.putImageData(last,0,0);
}
document.getElementById("undoBtn").onclick = undo;

/* ---------------- FLOOD FILL ---------------- */

function floodFill(startX, startY, fillColor) {
  const imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
  const data = imgData.data;
  const width = canvas.width;
  const height = canvas.height;

  const stack = [[startX,startY]];
  const index = (startY * width + startX) * 4;

  const target = [
    data[index],
    data[index+1],
    data[index+2]
  ];

  const fill = hexToRgb(fillColor);

  if (matchColor(target, fill)) return;

  while(stack.length){
    const [x,y] = stack.pop();
    const i = (y * width + x) * 4;

    const current = [
      data[i],
      data[i+1],
      data[i+2]
    ];

    if (!matchColor(current, target)) continue;

    data[i] = fill[0];
    data[i+1] = fill[1];
    data[i+2] = fill[2];
    data[i+3] = 255;

    if (x>0) stack.push([x-1,y]);
    if (x<width-1) stack.push([x+1,y]);
    if (y>0) stack.push([x,y-1]);
    if (y<height-1) stack.push([x,y+1]);
  }

  ctx.putImageData(imgData,0,0);
}

function hexToRgb(hex){
  const bigint = parseInt(hex.replace("#",""),16);
  return [(bigint>>16)&255,(bigint>>8)&255,bigint&255];
}

function matchColor(a,b){
  return a[0]===b[0] && a[1]===b[1] && a[2]===b[2];
}

/* ---------------- DRAW ENGINE ---------------- */

let drawing = false;
let brushColor = "#2563eb";
let brushSize = 20;

canvas.addEventListener("pointerdown", e => {
  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  const x = Math.floor((e.clientX - rect.left) * dpr);
  const y = Math.floor((e.clientY - rect.top) * dpr);

  pushUndo();

  if (gameMode === "fill") {
    floodFill(x,y,brushColor);
    return;
  }

  if (gameMode === "paint") {
    drawing = true;
    ctx.beginPath();
    ctx.moveTo(x,y);
  }
});

canvas.addEventListener("pointermove", e => {
  if (!drawing || gameMode !== "paint") return;

  const rect = canvas.getBoundingClientRect();
  const dpr = window.devicePixelRatio || 1;
  const x = (e.clientX - rect.left) * dpr;
  const y = (e.clientY - rect.top) * dpr;

  ctx.strokeStyle = brushColor;
  ctx.lineWidth = brushSize;
  ctx.lineCap = "round";
  ctx.lineTo(x,y);
  ctx.stroke();
});

canvas.addEventListener("pointerup", ()=> drawing=false);
canvas.addEventListener("pointerleave", ()=> drawing=false);

/* ---------------- NAV BUTTONS ---------------- */

document.getElementById("nextBtn").onclick = ()=> {
  if (gameMode !== "blank") loadPage(currentPage+1);
};
document.getElementById("prevBtn").onclick = ()=> {
  if (gameMode !== "blank") loadPage(currentPage-1);
};
document.getElementById("cleanBtn").onclick = ()=> {
  if (gameMode === "blank") {
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,canvas.width,canvas.height);
  } else {
    loadPage(currentPage);
  }
};

loadPage(0);
</script>
