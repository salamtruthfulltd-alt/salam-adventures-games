<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Pop the Bubbles | Salam Adventures</title>
  <style>
    :root{
      --bg1:#ffe9f3; --bg2:#e9fbff;
      --ink:#111827; --muted:#6b7280;
      --radius:22px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:18px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background:
        radial-gradient(1200px 700px at 15% 10%, rgba(255,79,163,.22), transparent 60%),
        radial-gradient(1000px 650px at 85% 30%, rgba(56,189,248,.22), transparent 55%),
        radial-gradient(900px 550px at 45% 90%, rgba(251,191,36,.18), transparent 55%),
        linear-gradient(135deg, var(--bg1), var(--bg2));
      overflow:hidden;
      color:var(--ink);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }

    /* Flashing sparkly border */
    .panel{
      width:min(980px, 100%);
      position:relative;
      z-index:1;
      border-radius:calc(var(--radius) + 10px);
      padding:6px;
      background: conic-gradient(from 0deg,
        #ff4fa3, #38bdf8, #fbbf24, #34d399, #a78bfa, #ff4fa3);
      animation: rainbowSpin 2.8s linear infinite;
      box-shadow: 0 18px 45px rgba(0,0,0,.16);
    }
    .panel::after{
      content:"";
      position:absolute;
      inset:-6px;
      border-radius:calc(var(--radius) + 16px);
      background:
        radial-gradient(circle at 20% 30%, rgba(255,255,255,.85), transparent 30%),
        radial-gradient(circle at 80% 25%, rgba(255,255,255,.75), transparent 28%),
        radial-gradient(circle at 60% 85%, rgba(255,255,255,.65), transparent 30%),
        radial-gradient(circle at 30% 80%, rgba(255,255,255,.55), transparent 32%);
      filter: drop-shadow(0 0 12px rgba(255,255,255,.55));
      opacity:.55;
      animation: borderSparkle 1.6s ease-in-out infinite alternate;
      pointer-events:none;
      mix-blend-mode: screen;
    }
    @keyframes rainbowSpin{0%{filter:hue-rotate(0deg)}100%{filter:hue-rotate(360deg)}}
    @keyframes borderSparkle{0%{opacity:.30; transform:scale(1)}100%{opacity:.78; transform:scale(1.01)}}

    .inner{
      background:rgba(255,255,255,.86);
      backdrop-filter: blur(10px);
      border-radius:var(--radius);
      padding:18px 18px 14px;
      border: 1px solid rgba(0,0,0,.06);
    }

    .top{
      display:flex; align-items:flex-start; justify-content:space-between;
      gap:12px; flex-wrap:wrap;
    }
    h1{
      margin:0;
      font-weight:1000;
      letter-spacing:-.02em;
      font-size: clamp(18px, 3.2vw, 28px);
    }
    .sub{
      margin:6px 0 0;
      color:var(--muted);
      font-size:14px;
      line-height:1.35;
    }

    .controls{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:flex-end;
    }

    .pill{
      border-radius:999px;
      padding:8px 10px;
      font-weight:900;
      font-size:13px;
      border:1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.7);
      box-shadow: 0 10px 0 rgba(0,0,0,.08), 0 18px 26px rgba(0,0,0,.10);
      display:flex;
      gap:8px;
      align-items:center;
    }

    .btn{
      appearance:none; border:none; border-radius:16px;
      padding:10px 13px; font-weight:1000; cursor:pointer; font-size:13px;
      box-shadow: 0 10px 0 rgba(0,0,0,.12), 0 18px 26px rgba(0,0,0,.16);
      transition: transform .08s ease;
      background: linear-gradient(180deg, #111827, #0b1220);
      color:#fff;
      touch-action: manipulation;
    }
    .btn.secondary{
      background: linear-gradient(180deg, #ffffff, #f3f4f6);
      color:#111827;
      border:1px solid rgba(0,0,0,.12);
      box-shadow: 0 10px 0 rgba(0,0,0,.08), 0 18px 26px rgba(0,0,0,.12);
    }
    .btn:active{transform: translateY(2px); box-shadow: 0 8px 0 rgba(0,0,0,.12), 0 14px 22px rgba(0,0,0,.14);}

    .toggle{
      display:flex; align-items:center; gap:8px;
      font-size:13px; color:var(--muted);
      font-weight:900;
      user-select:none;
    }
    .toggle input{transform:scale(1.1)}

    .stage{
      margin-top:14px;
      position:relative;
      height: 560px;
      border-radius:18px;
      border:1px solid rgba(0,0,0,.10);
      overflow:hidden;
      box-shadow: 0 18px 40px rgba(0,0,0,.12);
      background: linear-gradient(180deg, rgba(191,231,255,.75), rgba(255,230,242,.75));
    }
    @media (max-width: 680px){
      .stage{height: 520px;}
    }

    /* Level backgrounds */
    .bg1{ background:
      radial-gradient(900px 450px at 30% 20%, rgba(255,255,255,.65), transparent 60%),
      linear-gradient(180deg, rgba(191,231,255,.95), rgba(255,230,242,.85));
    }
    .bg2{ background:
      radial-gradient(700px 420px at 70% 25%, rgba(255,255,255,.55), transparent 60%),
      radial-gradient(900px 520px at 30% 90%, rgba(167,243,208,.35), transparent 55%),
      linear-gradient(180deg, rgba(196,181,253,.55), rgba(147,197,253,.65));
    }
    .bg3{ background:
      radial-gradient(900px 520px at 50% 10%, rgba(255,255,255,.55), transparent 60%),
      radial-gradient(900px 520px at 50% 95%, rgba(251,191,36,.20), transparent 60%),
      linear-gradient(180deg, rgba(12,74,110,.80), rgba(88,28,135,.75));
    }

    /* sparkles drifting inside stage */
    .stageSparkle{
      position:absolute;
      width:10px; height:10px; border-radius:50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,.95), rgba(255,255,255,0) 70%);
      filter: drop-shadow(0 0 10px rgba(255,255,255,.65));
      opacity:0;
      animation: stageFloat linear forwards;
      pointer-events:none;
    }
    @keyframes stageFloat{
      0%{ transform: translateY(40px) scale(.7); opacity:0; }
      15%{ opacity:.85; }
      100%{ transform: translateY(-640px) scale(1.2); opacity:0; }
    }

    /* Bubble */
    .bubble{
      position:absolute;
      width:72px;
      height:72px;
      border-radius:50%;
      pointer-events:auto;
      cursor:pointer;
      touch-action: manipulation;
      background:
        radial-gradient(circle at 30% 30%, rgba(255,255,255,.95), rgba(255,255,255,.35) 35%, rgba(255,255,255,.12) 60%, rgba(255,255,255,0) 72%),
        radial-gradient(circle at 70% 75%, rgba(56,189,248,.25), rgba(56,189,248,0) 55%),
        radial-gradient(circle at 55% 45%, rgba(255,79,163,.18), rgba(255,79,163,0) 60%);
      border: 2px solid rgba(255,255,255,.65);
      box-shadow:
        inset 0 0 18px rgba(255,255,255,.55),
        0 18px 35px rgba(0,0,0,.12);
      transform: translateZ(0);
      animation: bob 2.8s ease-in-out infinite;
    }
    .bubble::after{
      content:"";
      position:absolute;
      inset:10px 14px auto auto;
      width:18px; height:18px;
      border-radius:50%;
      background: rgba(255,255,255,.8);
      filter: blur(.2px);
      opacity:.85;
    }
    @keyframes bob{
      0%,100%{transform: translateY(0)}
      50%{transform: translateY(-10px)}
    }

    /* pop animation */
    .pop{
      animation: pop 220ms ease-out forwards;
    }
    @keyframes pop{
      to{ transform: scale(1.35); opacity:0; }
    }

    /* glitter burst on pop */
    .glitter{
      position:absolute;
      width:8px; height:8px;
      border-radius:50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,1), rgba(255,255,255,0) 70%);
      filter: drop-shadow(0 0 10px rgba(255,255,255,.85));
      pointer-events:none;
      animation: glitterPop 520ms ease-out forwards;
    }
    @keyframes glitterPop{
      0%{opacity:0; transform: translate(0,0) scale(.6);}
      15%{opacity:1;}
      100%{opacity:0; transform: translate(var(--dx), var(--dy)) scale(1.2);}
    }

    .footerNote{
      margin-top:10px;
      color:var(--muted);
      font-size:13px;
      font-weight:800;
      text-align:center;
    }
  </style>
</head>

<body>
  <main class="panel">
    <div class="inner">
      <div class="top">
        <div>
          <h1>Pop the Bubbles</h1>
          <p class="sub">Tap the floating bubbles! Pop pop pop! ðŸŽˆâœ¨</p>
        </div>

        <div class="controls">
          <div class="pill" aria-label="Score">
            âœ… Popped: <span id="score">0</span>
          </div>
          <div class="pill" aria-label="Level">
            ðŸŒˆ Level: <span id="level">1</span>
          </div>
          <button class="btn secondary" id="levelBtn" type="button">Next level</button>
          <button class="btn secondary" id="resetBtn" type="button">Reset</button>

          <label class="toggle" title="Sound effects">
            <input id="sfxToggle" type="checkbox" checked />
            SFX
          </label>
          <label class="toggle" title="Soft background music">
            <input id="musicToggle" type="checkbox" checked />
            Music
          </label>
        </div>
      </div>

      <div class="stage bg1" id="stage" aria-label="Bubble popping area"></div>

      <div class="footerNote">Tip: On phones/tablets, tap bubbles gently. ðŸŽ¶ Music starts after your first tap.</div>
    </div>
  </main>

<script>
  const stage = document.getElementById("stage");
  const scoreEl = document.getElementById("score");
  const levelEl = document.getElementById("level");
  const levelBtn = document.getElementById("levelBtn");
  const resetBtn = document.getElementById("resetBtn");
  const sfxToggle = document.getElementById("sfxToggle");
  const musicToggle = document.getElementById("musicToggle");

  let score = 0;
  let level = 1;
  let startedAudio = false;

  // Level settings: bubble count + speed + background
  const LEVELS = [
    { bg:"bg1", spawnMs: 900, bubbleSize: 72, speed: 0.55 },
    { bg:"bg2", spawnMs: 750, bubbleSize: 66, speed: 0.70 },
    { bg:"bg3", spawnMs: 620, bubbleSize: 60, speed: 0.88 }
  ];

  // --- Audio (WebAudio) ---
  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let ctx = null;

  function ensureAudio(){
    if (!ctx) ctx = new AudioCtx();
  }

  // Soft background music (simple kid-friendly arpeggio)
  let musicTimer = null;
  let musicGain = null;

  function startMusic(){
    ensureAudio();
    if (!ctx || musicTimer) return;

    musicGain = ctx.createGain();
    musicGain.gain.value = 0.035; // very soft
    musicGain.connect(ctx.destination);

    const notes = [261.63, 329.63, 392.00, 523.25, 392.00, 329.63]; // C E G C G E
    let i = 0;

    musicTimer = setInterval(() => {
      if (!musicToggle.checked || ctx.state !== "running") return;
      const osc = ctx.createOscillator();
      const g = ctx.createGain();
      osc.type = "sine";
      osc.frequency.value = notes[i % notes.length];
      g.gain.setValueAtTime(0, ctx.currentTime);
      g.gain.linearRampToValueAtTime(0.8, ctx.currentTime + 0.01);
      g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.22);
      osc.connect(g);
      g.connect(musicGain);
      osc.start();
      osc.stop(ctx.currentTime + 0.24);
      i++;
    }, 260);
  }

  function stopMusic(){
    if (musicTimer){
      clearInterval(musicTimer);
      musicTimer = null;
    }
    if (musicGain){
      try{ musicGain.disconnect(); }catch(e){}
      musicGain = null;
    }
  }

  // Pop SFX
  function popSfx(){
    if (!sfxToggle.checked) return;
    ensureAudio();
    if (!ctx || ctx.state !== "running") return;

    // quick "pop": noise burst + short pitch drop
    const dur = 0.08;

    // noise
    const bufferSize = Math.floor(ctx.sampleRate * dur);
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++){
      data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize);
    }
    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const bp = ctx.createBiquadFilter();
    bp.type = "bandpass";
    bp.frequency.value = 1800;
    bp.Q.value = 0.9;

    const g = ctx.createGain();
    g.gain.value = 0.12;

    noise.connect(bp);
    bp.connect(g);
    g.connect(ctx.destination);
    noise.start();
    noise.stop(ctx.currentTime + dur);

    // tiny tone
    const osc = ctx.createOscillator();
    const og = ctx.createGain();
    osc.type = "triangle";
    osc.frequency.setValueAtTime(520, ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(220, ctx.currentTime + 0.07);
    og.gain.setValueAtTime(0.06, ctx.currentTime);
    og.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.07);
    osc.connect(og);
    og.connect(ctx.destination);
    osc.start();
    osc.stop(ctx.currentTime + 0.08);
  }

  // Start audio on first user gesture (browser policy)
  function userGestureStartAudio(){
    if (startedAudio) return;
    startedAudio = true;
    ensureAudio();
    if (ctx && ctx.state === "suspended") ctx.resume();
    if (musicToggle.checked) startMusic();
  }

  document.addEventListener("pointerdown", userGestureStartAudio, { once:true });

  musicToggle.addEventListener("change", () => {
    if (!startedAudio) return;
    if (musicToggle.checked) startMusic();
    else stopMusic();
  });

  // --- Bubbles ---
  let spawnTimer = null;
  let animTimer = null;
  const bubbles = new Set();

  function rand(min,max){ return min + Math.random()*(max-min); }

  function setLevel(n){
    level = n;
    levelEl.textContent = level;

    // update stage background class
    stage.classList.remove("bg1","bg2","bg3");
    stage.classList.add(LEVELS[level-1].bg);

    // reset spawns
    stopLoops();
    clearBubbles();
    startLoops();
  }

  function clearBubbles(){
    bubbles.forEach(b => b.remove());
    bubbles.clear();
  }

  function spawnBubble(){
    const cfg = LEVELS[level-1];
    const b = document.createElement("div");
    b.className = "bubble";
    b.style.width = cfg.bubbleSize + "px";
    b.style.height = cfg.bubbleSize + "px";

    // start near bottom, random x
    const stageRect = stage.getBoundingClientRect();
    const x = rand(10, stageRect.width - cfg.bubbleSize - 10);
    const y = stageRect.height + rand(20, 120);

    b.style.left = x + "px";
    b.style.top = y + "px";

    // movement speed + drift
    b.dataset.vy = (-cfg.speed * rand(0.9, 1.25)).toString();
    b.dataset.vx = (rand(-0.20, 0.20)).toString();

    b.addEventListener("pointerdown", (e) => {
      e.preventDefault();
      userGestureStartAudio();
      popBubble(b);
    });

    stage.appendChild(b);
    bubbles.add(b);
  }

  function popBubble(b){
    if (!b || b.dataset.popped === "1") return;
    b.dataset.popped = "1";
    b.classList.add("pop");

    // sfx + score
    popSfx();
    score++;
    scoreEl.textContent = score;

    // glitter burst
    const rect = b.getBoundingClientRect();
    const srect = stage.getBoundingClientRect();
    const cx = rect.left - srect.left + rect.width/2;
    const cy = rect.top - srect.top + rect.height/2;
    burstGlitter(cx, cy);

    setTimeout(() => {
      try{ b.remove(); }catch(e){}
      bubbles.delete(b);
    }, 240);
  }

  function burstGlitter(x,y){
    for (let i=0;i<18;i++){
      const g = document.createElement("div");
      g.className = "glitter";
      g.style.left = (x-4) + "px";
      g.style.top = (y-4) + "px";
      g.style.setProperty("--dx", (rand(-140,140)) + "px");
      g.style.setProperty("--dy", (rand(-120,120)) + "px");
      g.style.animationDuration = (420 + Math.random()*260) + "ms";
      stage.appendChild(g);
      setTimeout(()=>{ try{g.remove()}catch(e){} }, 750);
    }
  }

  // subtle sparkles inside stage
  function spawnStageSparkle(){
    const s = document.createElement("div");
    s.className = "stageSparkle";
    const stageRect = stage.getBoundingClientRect();
    s.style.left = rand(0, stageRect.width) + "px";
    s.style.top = (stageRect.height + rand(10, 60)) + "px";
    const size = rand(6, 12);
    s.style.width = size + "px";
    s.style.height = size + "px";
    s.style.animationDuration = rand(4.5, 8.5) + "s";
    stage.appendChild(s);
    setTimeout(()=>{ try{s.remove()}catch(e){} }, 9500);
  }

  function tick(){
    const stageRect = stage.getBoundingClientRect();
    bubbles.forEach(b => {
      if (!b.isConnected) { bubbles.delete(b); return; }
      if (b.dataset.popped === "1") return;

      let x = parseFloat(b.style.left);
      let y = parseFloat(b.style.top);
      const vx = parseFloat(b.dataset.vx);
      const vy = parseFloat(b.dataset.vy);

      // move
      x += vx * 2.2;
      y += vy * 2.6;

      // gentle bounce off edges
      const w = parseFloat(b.style.width);
      if (x < 6){ x = 6; b.dataset.vx = (Math.abs(vx)).toString(); }
      if (x > stageRect.width - w - 6){ x = stageRect.width - w - 6; b.dataset.vx = (-Math.abs(vx)).toString(); }

      b.style.left = x + "px";
      b.style.top = y + "px";

      // remove if off top
      if (y < -120){
        try{ b.remove(); }catch(e){}
        bubbles.delete(b);
      }
    });
  }

  function startLoops(){
    const cfg = LEVELS[level-1];
    spawnTimer = setInterval(spawnBubble, cfg.spawnMs);
    animTimer = setInterval(tick, 16); // ~60fps
    // stage sparkles
    stageSparkleTimer = setInterval(spawnStageSparkle, 260);
  }

  function stopLoops(){
    if (spawnTimer){ clearInterval(spawnTimer); spawnTimer = null; }
    if (animTimer){ clearInterval(animTimer); animTimer = null; }
    if (stageSparkleTimer){ clearInterval(stageSparkleTimer); stageSparkleTimer = null; }
  }

  let stageSparkleTimer = null;

  // Buttons
  levelBtn.addEventListener("click", () => {
    userGestureStartAudio();
    const next = (level % LEVELS.length) + 1;
    setLevel(next);
  });

  resetBtn.addEventListener("click", () => {
    userGestureStartAudio();
    score = 0;
    scoreEl.textContent = score;
    setLevel(level);
  });

  // Init
  setLevel(1);
  startLoops();
</script>
</body>
</html>
