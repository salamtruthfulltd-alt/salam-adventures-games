<script>
  /* UPDATE THESE PATHS TO MATCH YOUR REPO STRUCTURE */
  const IMAGES = {
    star:   { title: "Star in the Clouds", file: "star.png" },
    balloon:{ title: "Balloon Surprise",   file: "balloon.png" },
    salam:  { title: "Salam Adventures",   file: "salam.png" }
  };

  const gallery = document.getElementById("gallery"), 
        stageWrap = document.getElementById("stageWrap"), 
        homeBtn = document.getElementById("homeBtn"), 
        shuffleBtn = document.getElementById("shuffleBtn"), 
        solvedCountEl = document.getElementById("solvedCount");
  
  const btn2 = document.getElementById("btn2"), 
        btn3 = document.getElementById("btn3"), 
        pTitle = document.getElementById("pTitle"), 
        hintImg = document.getElementById("hintImg"), 
        cv = document.getElementById("cv"), 
        ctx2d = cv.getContext("2d");

  const thumbStar = document.getElementById("thumbStar"), 
        thumbBalloon = document.getElementById("thumbBalloon"), 
        thumbSalam = document.getElementById("thumbSalam");

  let solvedCount = 0, gridN = 2, currentKey = null, img = null, pieces = [], dragging = null, board = { x: 0, y: 0, w: 0, h: 0 }, anim = null, completed = false;

  const AudioCtx = window.AudioContext || window.webkitAudioContext;
  let audioCtx = null;
  function ensureAudio(){ if (!audioCtx) audioCtx = new AudioCtx(); if (audioCtx.state === "suspended") audioCtx.resume(); }

  function successChime(){
    ensureAudio(); if (!audioCtx || audioCtx.state !== "running") return;
    const now = audioCtx.currentTime; const g = audioCtx.createGain(); g.gain.value = 0.06; g.connect(audioCtx.destination);
    [523.25, 659.25, 783.99].forEach((f,i)=>{
      const o = audioCtx.createOscillator(), og = audioCtx.createGain(); o.type = "sine"; o.frequency.value = f;
      og.gain.setValueAtTime(0.001, now + i*0.09); og.gain.exponentialRampToValueAtTime(1.0, now + i*0.09 + 0.01); og.gain.exponentialRampToValueAtTime(0.001, now + i*0.09 + 0.12);
      o.connect(og); og.connect(g); o.start(now + i*0.09); o.stop(now + i*0.09 + 0.13);
    });
  }

  function resizeCanvas(){
    const rect = cv.getBoundingClientRect(), dpr = Math.max(1, window.devicePixelRatio || 1);
    cv.width = Math.floor(rect.width * dpr); cv.height = Math.floor(rect.height * dpr);
    ctx2d.setTransform(dpr,0,0,dpr,0,0);
    const pad = 18, w = rect.width, h = rect.height, size = Math.min(w, h) - pad*2;
    board.w = size; board.h = size; board.x = (w - size)/2; board.y = (h - size)/2;
  }

  function loadImage(key){ 
    return new Promise((res, rej)=>{ 
      const im = new Image(); 
      im.onload = ()=> res(im); 
      im.onerror = ()=> rej(new Error("Fail")); 
      im.src = IMAGES[key].file; 
    }); 
  }

  function setDifficulty(n){ gridN = n; btn2.classList.toggle("on", n === 2); btn3.classList.toggle("on", n === 3); if (img) startPuzzle(currentKey); }

  function makePieces(){
    pieces = []; completed = false; const N = gridN, pw = board.w / N, ph = board.h / N, iw = img.naturalWidth, ih = img.naturalHeight;
    for (let r=0;r<N;r++) for (let c=0;c<N;c++) pieces.push({ r, c, sx: (c / N) * iw, sy: (r / N) * ih, sw: iw / N, sh: ih / N, tx: board.x + c*pw, ty: board.y + r*ph, x: 0, y: 0, w: pw, h: ph, placed: false });
  }

  function shufflePieces(){
    const rect = cv.getBoundingClientRect(), margin = 16;
    const spawnZones = [ {x: margin, y: margin, w: rect.width - margin*2, h: board.y - margin*2}, {x: margin, y: board.y + board.h + margin, w: rect.width - margin*2, h: rect.height - (board.y + board.h) - margin*2}, {x: margin, y: board.y + margin, w: board.x - margin*2, h: board.h - margin*2}, {x: board.x + board.w + margin, y: board.y + margin, w: rect.width - (board.x + board.w) - margin*2, h: board.h - margin*2} ].filter(z => z.w > 60 && z.h > 60);
    pieces.forEach(p=>{ p.placed = false; const z = spawnZones.length ? spawnZones[Math.floor(Math.random()*spawnZones.length)] : {x: margin, y: margin, w: rect.width - margin*2, h: rect.height - margin*2}; p.x = z.x + Math.random() * Math.max(1,(z.w - p.w)); p.y = z.y + Math.random() * Math.max(1,(z.h - p.h)); });
    pieces.sort(()=> Math.random() - 0.5);
  }

  function draw(){
    const rect = cv.getBoundingClientRect(); ctx2d.clearRect(0,0,rect.width,rect.height);
    ctx2d.save(); ctx2d.globalAlpha = 0.22; ctx2d.fillStyle = "#ffffff"; roundRect(ctx2d, board.x-10, board.y-10, board.w+20, board.h+20, 18); ctx2d.fill(); ctx2d.restore();
    ctx2d.save(); ctx2d.strokeStyle = "rgba(0,0,0,.18)"; ctx2d.lineWidth = 2; roundRect(ctx2d, board.x, board.y, board.w, board.h, 16); ctx2d.stroke(); ctx2d.restore();
    const N = gridN; ctx2d.save(); ctx2d.strokeStyle = "rgba(0,0,0,.10)"; ctx2d.lineWidth = 1;
    for (let i=1;i<N;i++){ 
        const x = board.x + i*(board.w/N), y = board.y + i*(board.h/N); 
        ctx2d.beginPath(); ctx2d.moveTo(x, board.y); ctx2d.lineTo(x, board.y+board.h); ctx2d.stroke(); 
        ctx2d.beginPath(); ctx2d.moveTo(board.x, y); ctx2d.lineTo(board.x+board.w, y); ctx2d.stroke(); 
    }
    ctx2d.restore();
    pieces.filter(p=>p.placed).forEach(p=>drawPiece(p, false));
    pieces.filter(
